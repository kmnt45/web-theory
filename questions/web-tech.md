# Web Tech

## 1. HTTP-запросы/ответы

`HTTP (HyperText Transfer Protocol)` — протокол прикладного уровня, по которому клиент (браузер) и сервер обмениваются данными. Работает поверх TCP (порт 80).

**TCP, TLS и HTTPS**

`TCP (Transmission Control Protocol)` — транспортный протокол, обеспечивающий надёжную и последовательную доставку данных, но без шифрования — данные передаются в открытом виде. Он:

- Делит данные на пакеты и собирает обратно в правильном порядке.

- Проверяет целостность данных и пересылает утерянные пакеты.

- Гарантирует доставку без потерь и дубликатов.

`TLS (Transport Layer Security)` — криптографический протокол, добавляющий безопасность поверх TCP. Он:

- Шифрует данные, чтобы никто не мог их перехватить и прочитать.

- Проверяет подлинность сервера с помощью TLS-сертификата (часто называемого "SSL-сертификатом" - устарел).

- Гарантирует целостность данных при передаче.

- Современный стандарт — TLS 1.3

`HTTPS = HTTP + TLS`

Работает по порту 443 и обеспечивает конфиденциальность, целостность и аутентичность данных.
Используется для форм, авторизации, API, банковских и любых защищённых сайтов.

**HTTP-запрос и HTTP-ответ состоят из:**

1. Стартовая строка/Строка статуса

   - Запрос: GET /index.html HTTP/1.1 (Метод, URL, Версия протокола)

   - Ответ: HTTP/1.1 200 OK (Версия протокола, Код состояния, Пояснение )

2. Заголовков (Headers) — метаданные о запросе/ответе.

3. Пустой строки — разделяет заголовки и тело.

4. Тела (Body) — данные (например JSON, HTML, файл и т.д.).

**Основные методы HTTP**

| Метод   | Идемпотентность | Назначение                                                                                                              |
|---------|-----------------|-------------------------------------------------------------------------------------------------------------------------|
| GET     | ✅               | Получить данные (параметры через URL).                                                                                  |
| POST    | ❌               | Отправить данные (формы, JSON).                                                                                         |
| PUT     | ✅               | Создать или заменить весь ресурс.                                                                                       |
| PATCH   | ❌ (частично)    | Частично обновить ресурс.                                                                                               |
| DELETE  | ✅               | Удалить ресурс.                                                                                                         |
| HEAD    | ✅               | Получить только заголовки без тела.                                                                                     |
| OPTIONS | ✅               | Позволяет запросить информацию о сервере, в том числе информацию о допускаемых к использованию на сервере HTTP-методов. |


`Идемпотентность` — повторный запрос не изменяет состояние ресурса.

`Безопасные методы (safe)`: GET, HEAD, OPTIONS — не изменяют состояние ресурса вообще (только для чтения).

**Основные заголовки запросов**

| Заголовок     | Назначение                                         |
|---------------|----------------------------------------------------|
| Host          | Указывает домен сервера.                           |
| User-Agent    | Информация о клиенте (браузере, ОС).               |
| Accept        | Какие форматы клиент готов принять.                |
| Authorization | Токен или данные аутентификации.                   |
| Cookie        | Отправка сохранённых данных пользователя.          |
| Content-Type  | Формат тела запроса (например `application/json`). |


**Коды ответов HTTP**

| Категория | Примеры                             | Назначение                           |
|-----------|-------------------------------------|--------------------------------------|
| 1xx       | 100 Continue                        | Информационные (редко используются). |
| 2xx       | 200 OK, 201 Created, 204 No Content | Успешное выполнение запроса.         |
| 3xx       | 301, 302, 304 Not Modified          | Перенаправления, кэширование.        |
| 4xx       | 400, 401, 403, 404, 409             | Ошибки клиента.                      |
| 5xx       | 500, 502, 503, 504                  | Ошибки сервера.                      |

- 200 — всё ок

- 201 — создано

- 204 — без содержимого

- 301 / 302 — редирект

- 304 — ресурс не изменён (используется для кэширования)

- 400 — неверный запрос

- 401 / 403 — нет доступа

- 404 — не найдено

- 409 — конфликт данных

- 500 / 502 / 503 / 504 — серверные ошибки

**HTTP/1.1 vs HTTP/2 vs HTTP/3**

| Особенность                | HTTP/1.1                                 | HTTP/2                                                            | HTTP/3 (QUIC)                                    |
|----------------------------|------------------------------------------|-------------------------------------------------------------------|--------------------------------------------------|
| Формат                     | Текстовый                                | Бинарный                                                          | Бинарный (на базе UDP)                           |
| Соединения                 | Несколько TCP-соединений                 | Одно TCP-соединение с мультиплексированием                        | Одно QUIC-соединение (UDP)                       |
| Сжатие заголовков          | Нет                                      | Да (HPACK)                                                        | Да (QPACK)                                       |
| Server Push                | ❌                                        | ✅ (но устаревает, браузеры убирают)                               | ❌                                                |
| Безопасность               | TLS поддерживается, но **не обязателен** | TLS требуется (в браузерах, ≥ TLS 1.2)                            | TLS 1.3 встроен в QUIC                           |
| Скорость                   | Средняя (задержки из-за TCP handshake)   | Быстрее (меньше задержек, мультиплексирование, сжатие заголовков) | Ещё быстрее (нет потерь на TCP, 0-RTT handshake) |
| Проблемы с потерей пакетов | Замедляет всё соединение                 | Замедляет всё соединение (TCP)                                    | Затрагивает только отдельные потоки              |
| Используемый транспорт     | TCP                                      | TCP                                                               | UDP                                              |

Подробнее: https://selectel.ru/blog/http-request/

## 2. Стадии работы браузера. Что происходит, когда вводим запрос в адресную строку браузера?

1. **Браузер определяет тип ввода:**

   - если это URL (https://example.com), он начинает загружать веб-страницу;

   - если это поисковый запрос (пример запроса), браузер передаёт его на поисковую систему (Google, Yandex и т.п.).

2. **Браузер сначала ищет ресурс в кэше:**

    - Memory Cache — данные из текущей сессии.

    - Disk Cache — ранее сохранённые файлы.

    - Service Worker Cache — если сайт работает через PWA.

   Если ресурс найден и не просрочен — он загружается из кэша без обращения к серверу.

3. **Если кэша нет, браузер выполняет DNS-запрос, чтобы узнать IP-адрес домена. Проверяются:**

    - локальный DNS-кэш,

    - DNS-провайдер,

    - при необходимости — корневые DNS-серверы.

4. **Между клиентом и сервером устанавливается TCP-соединение (трёхэтапное рукопожатие — 3-way handshake).**

   - клиент отправляет серверу SYN (Synchronize "Синхронизация" — запрос на установку соединения).

   - сервер отвечает SYN-ACK (Synchronize "Синхронизация" + Acknowledgment "Подтверждение" — сервер подтверждает запрос клиента и синхронизирует свои номера).

   - клиент отправляет ACK (Acknowledgment "Подтверждение" — подтверждает соединение), и TCP-соединение устанавливается.

5. **Если HTTPS, устанавливается защищённое соединение (TLS Handshake)**

    - выполняется TLS Handshake поверх TCP-соединения.

    - браузер проверяет сертификат сервера (X.509) и доверяет ему, если:
   
      - он подписан надёжным удостоверяющим центром (CA).

      - срок действия не истёк.

      - домен в сертификате совпадает с запрошенным.

    - стороны договариваются о версиях протокола и алгоритмах шифрования.

    - обмениваются ключами (или параметрами для их вычисления — например, через Diffie–Hellman).

    - создаётся зашифрованный канал для безопасной передачи данных.

6. **[Браузер отправляет HTTP-запрос (HTTP-request).](#1-http-запросыответы)**

7. **[Сервер отправляет ответ (HTTP-response).](#1-http-запросыответы)**

8. **[Парсинг и рендеринг страницы.](#3-парсинг-и-рендеринг-страницы)**

9. **Кэширование ресурсов**

    - Браузер сохраняет полученные ресурсы в кэш (в зависимости от заголовков Cache-Control, ETag, Expires) для ускорения последующих загрузок.

## 3. Парсинг и рендеринг страницы.

1. **Parsing (Парсинг)**

    - Браузер получает HTML и начинает синтаксический разбор (парсинг).

    - По мере чтения HTML создаётся DOM (Document Object Model), а CSS парсится в CSSOM (CSS Object Model).

    - Одновременно загружаются другие ресурсы: скрипты, изображения и шрифты.

2. **Render Tree Construction (Построение дерева рендеринга)**

    - DOM и CSSOM объединяются в Render Tree, которое содержит только видимые элементы и их стили.

    - Скрытые элементы (display: none) не включаются в Render Tree.

3. **Layout / Reflow (Расчёт размеров и позиций)**

    - На основе Render Tree браузер вычисляет размеры, положение и геометрию каждого элемента на странице.

    - Любое изменение, влияющее на размеры, положение, геометрию или структуру документа, вызывает Reflow — перерасчёт Layout.

4. **Painting (Отрисовка)**

    - Каждый элемент визуализируется: заливаются фоны, отрисовывается текст, границы, тени, изображения и т.д.

    - Изменения, не затрагивающие геометрию (например, color, background, visibility), вызывают только Repaint, без полного Reflow.

5. **Compositing (Композиция слоёв)**

    - Браузер разделяет элементы на слои (например, при использовании transform, opacity, position: fixed и т.д.).

    - Эти слои компонуются (composited) на GPU и выводятся на экран.

    - Именно на этом этапе используется аппаратное ускорение (GPU).

**Блокирующие и неблокирующие ресурсы:**

- Блокирующие:

    - CSS-файлы — блокируют рендеринг до загрузки и парсинга, так как без стилей нельзя корректно отрисовать страницу.

    - JS-файлы (без async/defer) — блокируют парсинг HTML, пока не загрузятся и не выполнятся, т.к. скрипт может изменять DOM.

- Неблокирующие:

    - [Скрипты с async/defer.](#5-атрибуты-тега-скрипт)

    - Изображения, видео, шрифты — не блокируют DOM, но могут задерживать визуальную полноту (First Contentful Paint / Largest Contentful Paint).

**Оптимизации CRP (Critical Rendering Path):**

- Минимизировать количество блокирующих ресурсов.

- Критический CSS выносить инлайн в `<head>`.

- Загружать JS с defer или async.

- Делить код на модули (Code Splitting, lazy-loading).

- Использовать preconnect, preload, dns-prefetch для ключевых ресурсов.

- Сжимать и минимизировать файлы (gzip, brotli).

- Использовать HTTP/2 или HTTP/3 для параллельной загрузки.

- Для анимаций применять transform и opacity, чтобы избежать Reflow и Repaint.

## 4. Какие анимации лучше использовать? Преимущества transform.

1. Почему transform:

   - Аппаратное ускорение — анимации выполняются на GPU, снижая нагрузку на CPU.

   - Изменение слоя, а не DOM — transform (translate, scale, rotate) влияет только на визуальное представление, не трогая геометрию и соседние элементы.

   - Без Reflow и лишнего Paint — браузеру не нужно пересчитывать Layout и перерисовывать страницу → анимации плавные и производительные.

2. Другие безопасные свойства:

   - opacity — изменение прозрачности не вызывает Reflow, подходит для плавных переходов.

3. Что избегать:

   - Анимации свойств, влияющих на Layout: width, height, top, left, margin, padding — они вызывают Reflow и Repaint, замедляя рендеринг.

## 5. Атрибуты тега скрипт.

1. `src`

    - Указывает путь к внешнему файлу скрипта (`.js`).

    - Если указан `src`, внутренний код между `<script>...</script>` игнорируется.

2. `async`

    - Загружается параллельно и выполняется сразу после загрузки.

    - Страница продолжает парситься параллельно.

    - Порядок выполнения не гарантирован, если несколько скриптов с `async`.

    - Работает только для внешних файлов (`src`).

3. `defer`

    - Загружается параллельно, выполняется после парсинга HTML (после построения DOM, но до события DOMContentLoaded).

    - Страница продолжает парситься параллельно.

    - Скрипты выполняются в порядке следования в HTML.

    - Идеально для скриптов, которые взаимодействуют с DOM.

    - Работает только для внешних файлов (`src`).

## 6. Webpack

`Webpack` — сборщик модулей (module bundler). Он объединяет JavaScript, CSS, изображения и другие ресурсы в оптимизированные файлы для ускорения загрузки и улучшения производительности.

**Основные концепции**

1. Tree Shaking

   - Удаляет неиспользуемый код из финального бандла.

   - Работает только с ES6 модулями (`import/export`).

   - Уменьшает размер бандла и ускоряет загрузку.

2. Code splitting (Чанки)

   - Разделение кода на части (chunks) для загрузки по мере необходимости.

   - Статические чанки (entry chunks): загружаются при первой загрузке приложения, формируются из точек входа (`entry`).

   - Динамические чанки (lazy-loaded): создаются при динамическом импорте модулей (`import()`), загружаются только при необходимости.

   - Позволяет сократить начальный объём кода и улучшить производительность.

3. Проксирование (dev server proxy)

   - Механизм `webpack-dev-server` для перенаправления API-запросов с фронтенда на бэкенд во время разработки.

   - Используется для обхода CORS и удобной отладки API.

   - Работает в режиме реального времени, позволяет разрабатывать/тестировать фронтенд без запуска полноценного бэкенд на другом порту.

## 7. Политика одинакового источника (same-origin policy)

`Политика одинакового источника (same-origin policy)` — механизм безопасности браузера, который ограничивает доступ скриптов одного источника к данным другого источника (origin = протокол + домен + порт).

- SOP предотвращает чтение данных или взаимодействие с DOM на другом домене напрямую.

- Пример: страница с https://example.com не может читать ответ с https://another.com/api без разрешения сервера.

## 8. CORS (Cross-Origin Resource Sharing)

`CORS (Cross-Origin Resource Sharing)` — механизм, позволяющий веб-приложениям безопасно запрашивать ресурсы с другого домена.

Как работает:

1. Для "непростых" запросов браузер сначала отправляет preflight-запрос (`OPTIONS`), чтобы проверить, разрешает ли сервер кросс-доменный (cross-origin) доступ.

   Запрос является непростым, если он:

    - использует нестандартный метод (`PUT`, `DELETE`, `PATCH`);

    - содержит нестандартные заголовки (например, `Authorization`, `X-Custom-Header`);

    - имеет `Content-Type`, отличный от:

        - `application/x-www-form-urlencoded`,

        - `multipart/form-data`,

        - `text/plain`.
          Например, `application/json` делает запрос непростым.

2. Сервер отвечает заголовками, определяющими разрешения:

   - `Access-Control-Allow-Origin` — домен(ы), которым разрешён доступ (* для всех).

   - `Access-Control-Allow-Methods` — список разрешённых HTTP-методов.

   - `Access-Control-Allow-Headers` — заголовки, которые клиент может отправить.

   - `Access-Control-Allow-Credentials` — разрешение отправки куки и авторизационных данных (не работает с *).

   - `Access-Control-Max-Age` — время, на которое браузер может кэшировать preflight-ответ.

3. Если preflight-ответ удовлетворяет браузеру — выполняется основной запрос.
   В ответе на основной запрос сервер может дополнительно указать:
   `Access-Control-Expose-Headers` — заголовки основного ответа, доступные для чтения из JavaScript (по умолчанию разрешено читать только ограниченный набор стандартных заголовков).
   Если preflight-ответ не удовлетворяет браузеру — запрос блокируется.

**Зачем нужен CORS**

- Обеспечивает контролируемый доступ к ресурсам с других доменов.

- Настраивается на сервере с помощью HTTP-заголовков.

- Не является защитой от CSRF или XSS — эти угрозы требуют дополнительных мер.

## 9. JWT Авторизация

`JWT (JSON Web Token)` — это открытый стандарт (RFC 7519) для безопасной передачи данных в виде JSON-объекта между клиентом и сервером, с использованием криптографической подписи.

Структура JWT:

- Заголовок (Header): Содержит информацию о типе токена и используемом алгоритме подписи (например, HMAC SHA256 или RSA).

- Полезная нагрузка (Payload): Содержит утверждения (registered, public и private claims), такие как идентификатор пользователя, роль или срок действия токена.

- Подпись (Signature): Создается на основе заголовка и полезной нагрузки с использованием секретного ключа, что обеспечивает целостность данных и подтверждает, что токен был выдан сервером.

Токены:

`Access Token` — короткоживущий (минуты–часы), используется для каждого запроса к API. Хранится в памяти приложения (React state, Redux, Context) или другом безопасном хранилище.

`Refresh Token` — долгоживущий (дни–недели), хранится в httpOnly cookie и используется только для получения нового Access Token.

Принцип работы:

1. Пользователь логинится → сервер выдаёт Access и Refresh токены.

2. Access Token отправляется с каждым запросом (заголовок Authorization).

3. Когда Access Token истекает → клиент отправляет Refresh Token на сервер → получает новую пару токенов (Access и, при ротации, Refresh Token).

4. Если Refresh Token истёк → пользователь разлогинивается.

Безопасность:

- Refresh Token хранится в `httpOnly` и `Secure` cookie, защищая от XSS. При этом важно учитывать защиту от CSRF (например, через SameSite=strict).

- Access Token хранится в памяти или безопасном хранилище, короткий срок жизни снижает риск компрометации.

- Сервер проверяет подпись JWT и срок жизни токена, чтобы гарантировать целостность и аутентичность данных.

- Ротация Refresh Token повышает безопасность: старый Refresh Token становится недействительным после выдачи нового.

- Минимизируйте хранение токенов в localStorage или других уязвимых местах, чтобы снизить риск XSS.

Реализация на фронтенде:

- Axios interceptors: если запрос возвращает 401, перехватчик автоматически отправляет запрос на обновление токенов и повторяет исходный запрос.

- Таймер: декодируем поле exp → заранее обновляем Access Token.

- Redux middleware:

  - Перехватывает экшены, требующие авторизации.

  - Проверяет срок жизни Access Token перед выполнением запроса.

  - Если токен просрочен → отправляет Refresh Token на сервер, получает новый Access Token, обновляет Redux store и повторяет исходный экшен.

  - Если Refresh Token истёк → диспатчит экшен logout.

  - Можно реализовать очередь запросов, чтобы несколько параллельных запросов не запускали несколько refresh-запросов одновременно (race condition).

Особенности:

- Чтобы сервер мог корректно сетить куки, нужно указывать `withCredentials: true` в axios.

- После обновления токенов они автоматически сохраняются и используются при следующих запросах.

## 10. Методы для хранения данных в браузере? Что такое Local Storage? Чем отличается от Session Storage? Какие данные хранят в Local Storage? Что такое cookie? Какие виды cookie бывают? К каким cookie нельзя получить доступ через JS? Для чего они нужны? Как работают? Какие данные хранят в cookie?

1. `LocalStorage` — это веб-хранилище, встроенное в браузер, которое позволяет сохранять данные в строковом формате `ключ=значение` на стороне клиента. Данные сохраняются после перезагрузки страницы и даже закрытия браузера, пока их не удалят вручную или через код. Максимальный размер обычно 5–10 МБ на домен (зависит от браузера).

   Какие данные хранят в LocalStorage:

   - Настройки пользователя (тема, язык, интерфейс)

   - Кешированные данные (списки, результаты запросов)

   - Токены авторизации (если не критично хранить в HttpOnly cookie)

   - Любые данные, которые должны сохраняться между сессиями и вкладками

2. `SessionStorage` — аналогичен LocalStorage, но данные живут только в рамках одной вкладки/сессии (5 МБ). Полезен для временных данных, которые не нужны после закрытия вкладки: шаги форм, сессия конкретной вкладки.

3. `Cookies` — это небольшие строковые данные в формате `ключ=значение` (до 4 КБ), которые сервер передаёт браузеру, а браузер сохраняет их и автоматически отправляет при последующих HTTP-запросах к тому же домену.
   
   | Вид cookie              | Основные флаги / характеристики                                     | Для чего нужны / Назначение                                         | Тип данных                    | Пример `Set-Cookie`                                                                                                           |
   | ----------------------- | ------------------------------------------------------------------- | ------------------------------------------------------------------- | ----------------------------- | ----------------------------------------------------------------------------------------------------------------------------- |
   | **Session cookies**     | Временные, удаляются при закрытии браузера                          | Хранение состояния сессии пользователя, авторизация                 | Идентификатор сессии          | `Set-Cookie: sessionId=abc123; Path=/`                                                                                        |
   | **Persistent cookies**  | Хранятся до истечения срока (`Expires` / `Max-Age`)                 | Запоминание настроек, предпочтений, логин “Запомнить меня”          | Настройки пользователя        | `Set-Cookie: theme=dark; Expires=Fri, 31 Dec 2026 23:59:59 GMT; Path=/`<br>`Set-Cookie: theme=dark; Max-Age=31536000; Path=/` |
   | **First-party cookies** | Устанавливаются текущим доменом                                     | Персонализация и аналитика на сайте                                 | Настройки, идентификаторы     | `Set-Cookie: userId=42; Domain=example.com; Path=/`                                                                           |
   | **Third-party cookies** | Устанавливаются сторонними доменами                                 | Реклама, аналитика, трекинг                                         | Отслеживание и аналитика      | `Set-Cookie: ga=GA1.2.1234567890.1678901234; Domain=google-analytics.com; Path=/`                                             |
   | **Secure cookies**      | Передаются только по HTTPS                                          | Безопасная передача токенов авторизации                             | Токены безопасности / auth    | `Set-Cookie: authToken=xyz; Secure; HttpOnly; Path=/`                                                                         |
   | **HttpOnly cookies**    | Недоступны из JS                                                    | Защита сессионных данных от кражи через JS, доступно только серверу | Идентификатор сессии / токены | `Set-Cookie: sessionId=abc123; HttpOnly; Path=/`                                                                              |
   | **SameSite cookies**    | Контролируют отправку при кросс-сайтовых запросах (`Strict`, `Lax`) | Защита от CSRF-атак                                                 | Идентификатор сессии / токены | `Set-Cookie: sessionId=abc123; SameSite=Strict; Path=/`                                                                       |

4. `IndexedDB`

   - Встроенная NoSQL база данных для хранения больших объёмов данных (десятки/сотни МБ).

   - Асинхронный доступ, транзакции, индексы.

   - Отлично подходит для PWA, оффлайн-приложений, сложных структурированных данных.

## 11. Как поддерживать постоянное соединение?

1. WebSockets:

   - WebSockets позволяют установить двустороннее постоянное соединение между клиентом и сервером. Это полезно для
     приложений, требующих реального времени, таких как чаты или игры.
   - Как это работает:
     - Клиент инициирует соединение через HTTP-запрос с заголовком Upgrade.
     - Сервер принимает запрос и устанавливает постоянное соединение.
     - После установки соединения обе стороны могут отправлять данные в любое время.

    ```js
    import {useEffect, useState} from "react";
    
    const WebSocketExample = () => {
        const [messages, setMessages] = useState([]);
        const [socket, setSocket] = useState(null);
    
        useEffect(() => {
            const ws = new WebSocket("ws://example.com/socket");
            setSocket(ws);
    
            ws.onmessage = (event) => {
                setMessages((prevMessages) => [...prevMessages, event.data]);
            };
    
            return () => {
                ws.close();
            };
        }, []);
    
        return (
            <div>
                <h2>Messages</h2>
                {messages.map((msg, index) => (
                    <p key={index}>{msg}</p>
                ))}
            </div>
        );
    };
    
    export default WebSocketExample;
    ```

2. Server-Sent Events (SSE):

   - SSE — это односторонний канал, где сервер может отправлять обновления клиенту через HTTP-соединение.
   - SSE хорошо подходит для приложений, где сервер регулярно отправляет данные (например, обновления ленты новостей).

    ```js
    import {useEffect, useState} from "react";
    
    const SSEExample = () => {
        const [data, setData] = useState([]);
    
        useEffect(() => {
            const eventSource = new EventSource("http://example.com/sse");
    
            eventSource.onmessage = (event) => {
                setData((prevData) => [...prevData, event.data]);
            };
    
            return () => {
                eventSource.close();
            };
        }, []);
    
        return (
            <div>
                <h2>Data from SSE</h2>
                {data.map((item, index) => (
                    <p key={index}>{item}</p>
                ))}
            </div>
        );
    };
    
    export default SSEExample;
    ```

3. Long Polling:

   - При использовании long polling клиент отправляет запрос на сервер, сервер не отвечает сразу, а задерживает ответ
     до появления новых данных. Получив ответ, клиент сразу отправляет новый запрос, поддерживая иллюзию постоянного соединения.
   - Это более старый подход по сравнению с WebSocket и SSE, но все еще может быть полезен для некоторых сценариев.

    ```js
    import {useEffect, useState} from "react";
    import axios from "axios";
    
    const LongPollingExample = () => {
        const [data, setData] = useState([]);
    
        const pollData = async () => {
            try {
                const response = await axios.get("http://example.com/long-polling");
                setData((prevData) => [...prevData, response.data]);
                pollData(); // Запрашиваем данные снова после получения ответа
            } catch (error) {
                console.error(error);
            }
        };
    
        useEffect(() => {
            pollData();
        }, []);
    
        return (
            <div>
                <h2>Data from Long Polling</h2>
                {data.map((item, index) => (
                    <p key={index}>{item}</p>
                ))}
            </div>
        );
    };
    
    export default LongPollingExample;
    ```

## 12. Архитектура проекта и ее отличие от структуры. Какие архитектуры использовал?

`Архитектура проекта` — это подход и принципы организации кода, определяющие взаимодействие между слоями приложения, ответственность модулей, способы передачи данных.
Архитектура отвечает на вопросы: _Как разделять бизнес-логику и UI? Как общаются модули? Где хранить состояние? Как расширять проект?_

`Структура проекта` — это физическая организация файлов и папок (например, папка `components/`, `pages/`, `store/`, `services/`), то есть где что лежит, но не то, как это взаимодействует.

**Feature-Sliced Design (FSD)**

  - Архитектурно: проект был разделён на слои `app`, `processes`, `pages`, `features`, `entities`, `shared`. Это помогало изолировать фичи, упрощало масштабирование и поддержку кода.

  - Структурно: каждая фича имела свою папку с компонентами, сервисами и стором. Например: `features/auth/components/`, `entities/user/store/`.

- Также использовал Redux для управления глобальным состоянием, что обеспечивало предсказуемый поток данных и упрощало дебаг.

- Для небольших проектов применял более простую структурную организацию: `components/`, `pages/`, `services/`, `store/` и т.д. без сложного деления на фичи

## 13. Приватные вкладки (по хранилищам), отличие от обычных.

Да, я сталкивался с тестированием работы приложений в приватных вкладках браузеров. Приватный режим создаёт отдельный изолированный контейнер для всех данных текущей сессии: история, cookies, хранилища и кэш не сохраняются после закрытия окна.

**Основные отличия от обычных вкладок:**

1. Cookies и авторизация:

   - В приватном режиме cookies живут только в рамках текущей сессии.

   - После закрытия окна все cookies удаляются, поэтому при повторном открытии нужно авторизоваться заново.

   - Это полезно для тестирования логики входа/выхода и сценариев с истечением сессии.

2. LocalStorage и SessionStorage:

   - В обычном режиме localStorage хранит данные между сессиями. В приватном — данные удаляются при закрытии.

   - sessionStorage работает аналогично: живёт только в текущей вкладке.

   - Если приложение опирается на эти API, нужно учитывать, что в приватном режиме пользователь может потерять данные.

3. IndexedDB и оффлайн-функционал:

   - IndexedDB доступен, но в некоторых браузерах (например, Safari) он может быть отключён или иметь очень маленький лимит.

   - Это важно для PWA или приложений с оффлайн-режимом.

4. Service Workers и кэширование:

   - Service Workers работают, но в приватном режиме их кэш очищается после закрытия окна.

   - Это значит, что приложение не сможет полагаться на долгосрочный оффлайн-кэш.

5. Безопасность и тестирование:

   - Приватный режим полезен для проверки изоляции пользовательских данных, особенно при работе с токенами, JWT и хранением конфиденциальной информации.

   - Хорошая практика — проверять, что приложение не ломается, если хранилища недоступны или выбрасывают ошибки (QuotaExceededError в Safari).

**В React-приложениях обычно стараюсь:**

- Хранить критичные данные (например, состояние авторизации) не только в браузерных хранилищах, но и в стейте (Redux, zustand, React Query и т.д.).

- Оборачивать обращения к localStorage/IndexedDB в try-catch и иметь фолбэк (например, хранение данных только в памяти).

- Учитывать сценарии, когда приложение открыто в приватном режиме, и уведомлять пользователя об ограничениях.

Таким образом, приватные вкладки — это не просто «режим без истории», а отдельный sandbox, где данные существуют только в рамках текущей сессии. Для фронтенда это важно с точки зрения авторизации, работы с кешами и UX.

## 14. Браузерное кеширование (статики, запросов, на уровне браузеров, без стейт менеджеров). Заголовки кеш контрол.

Да, я работал с браузерным кэшированием на уровне статики и HTTP-запросов.

1. Типы кэширования:

   - Кэш статики (Static Assets): изображения, шрифты, JS и CSS файлы. Браузер может хранить их локально и использовать при повторных посещениях.

   - Кэш AJAX-запросов / API: ответы GET-запросов могут кэшироваться браузером, если сервер возвращает соответствующие HTTP-заголовки.

2. Заголовки Cache-Control:

   - public / private — управляет тем, может ли кэшироваться на прокси-серверах и в браузере.

   - max-age=N — время в секундах, сколько ресурс считается свежим.

   - no-cache — браузер проверяет с сервером актуальность ресурса перед использованием.

   - no-store — запрещает хранение в кэше полностью.

   - must-revalidate — после истечения max-age ресурс должен быть проверен с сервером.

3. Другие механизмы:

   - ETag — уникальный идентификатор ресурса; браузер посылает If-None-Match и сервер отвечает 304, если ресурс не изменился.

   - Last-Modified / If-Modified-Since — похожий подход по дате последнего изменения.

4. Практика в фронтенде:

   - Для React-приложений использовал кэширование статики через service-worker (PWA), а также HTTP-заголовки на CDN.

   - Настраивал оптимальные Cache-Control для JS/CSS с версионированием файлов, чтобы при изменении контента браузер обновлял кэш.

   - При работе с API важно учитывать, что GET-запросы можно кэшировать, POST — нет, и при необходимости принудительно сбрасывать кэш через заголовки.

## 15. Что такое Кроссбраузерность? Отличается ли то, как воспринимают разные браузеры, написанный код? Какие инструменты применяют, для автоматизации контроля кроссбраузерности?

`Кроссбраузерность` — это способность веб-приложения корректно работать в разных браузерах (Chrome, Firefox, Safari, Edge и др.) и на разных устройствах. Важно, чтобы UI, функциональность и производительность были одинаковыми для всех пользователей.
Один и тот же код может работать по-разному из-за различий в поддержке HTML, CSS, JS и API браузеров. Примеры проблем: старые браузеры не поддерживают ES6, flexbox, некоторые CSS-свойства или API.

Инструменты для контроля:

- Автоматизация тестов: Selenium, Cypress, Playwright, Puppeteer

- Онлайн-сервисы: BrowserStack, Sauce Labs, CrossBrowserTesting

- Транспилеры и полифилы: Babel, Polyfill.io

💡 Идея: тестируем работу сайта во всех целевых браузерах и при необходимости используем полифилы/транспилеры для совместимости.

## 16. Какие процессы проходит современное фронтенд-приложение, чтобы из “строчек кода“ превратиться в работающий продукт, на стенде заказчика. Уточнение: интересует процесс создания опыта разработки, какие инструменты применяются и какие трансформации проводятся над кодом?

Глубокий вопрос, лень писать, потом добавлю.

## 17. Почему чаще, для работы над проектами, делают выбор в пользу фреймворков?

Фреймворки выбирают, потому что они упрощают разработку и поддержку приложений:

- Предоставляют структуру и компоненты для организованного кода.

- Обеспечивают реактивность интерфейса и управление состоянием.

- Позволяют повторно использовать код и ускоряют разработку.

- Имеют экосистему библиотек, инструментов и сообщество для быстрого решения задач.

💡 Итог: экономят время, повышают качество и масштабируемость проекта.