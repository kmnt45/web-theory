# JavaScript

## 1. Что такое ECMAScript? В чём отличие от JavaScript?

`ECMAScript` — это спецификация, стандарт скриптовых языков программирования, он является основой JS, поэтому любые изменения ECMAScript отражаются на JS.

Что было добавлено в ES6:

- Стрелочные функции и интерполяция в строках
- Ключевые слова let и const
- Блочная видимость
- Параметры по умолчанию
- Классы и наследование
- Оператор for-of для перебора итерируемых объектов в цикле
- spread и rest операторы
- Promises
- Модули

## 2. Типы данных?

Примитивы хранятся непосредственно по значению:

- `number` — для чисел (целые и с плавающей точкой).

- `string` — для строк.

- `boolean` — логический тип (true / false).

- `undefined` — значение по умолчанию для:
  - переменной, которой не было присвоено значение;
  - функции, которая ничего не возвращает явно, например, console.log(1);
  - несуществующего свойства объекта.

- `null` — значение, которое присваивается переменной явно.

  При сравнении null и undefined мы получаем true, когда используем оператор ==, и false при использовании оператора ===.

- `symbol` — уникальные идентификаторы.
  ```javascript
  const sym1 = Symbol();
  const sym2 = Symbol();
  console.log(sym1 === sym2); // false
  ```
  
  Символы часто используют для создания скрытых свойств объектов. Они не отображаются в for...in и не конфликтуют с другими ключами.
  Также есть well-known symbols, например Symbol.iterator, который определяет поведение объектов при итерации (for...of, спред и т.д.).

- `bigint` — для целых чисел произвольной длины.
  ```javascript
  const big = BigInt(12345678901234567890n);
  ```

Объекты хранятся по ссылке и могут содержать множество значений и методов:

- `object` — для коллекций данных и более сложных структур.

## 3. Разница между let, const и var?

`var`
- Поднимается в начало области видимости при компиляции (имеет область видимости функции).
- Можно перезаписать и переопределить.

`let`
- Поднимается в начало области видимости при компиляции, но находится в TDZ до момента инициализации (имеет блочную область видимости).
- Можно перезаписать, но нельзя переопределить.

`const`
- Поднимается в начало области видимости при компиляции, но находится в TDZ до момента инициализации (имеет блочную область видимости).
- Нельзя перезаписать и нельзя переопределить.

## 4. Что такое временная мёртвая зона (temporal dead zone)?

`Временная мёртвая зона (temporal dead zone)` — это период времени между началом области видимости, где объявлена переменная с `let` или `const`, и
моментом, когда эта переменная инициализирована. В этот период доступ к переменной вызывает ошибку.

## 5. Разница между Rest и Spread операторами?

`Spread оператор (...)` используется для разложения массива или объекта на отдельные элементы или свойства.
Например, `[...arr]` или `{...obj}`.

`Rest оператор (...)` используется для сбора всех оставшихся аргументов функции в массив или свойства объекта в
объект. Например, `function(...args)` или `const {a, ...rest} = obj`.

## 6. Что такое деструктуризация?

`Деструктуризация` — это синтаксическая особенность, позволяющая извлекать значения из массивов или свойств из объектов и
присваивать их переменным. Например, для массива: `const [a, b] = [1, 2]`, для объекта: `const {x, y} = {x: 1, y: 2}`.

## 7. Разница между == и === (нестрогое/строгое равенство)?

`== (нестрогое равенство)` проверяет равенство значений с приведением типов. 

`=== (строгое равенство)` проверяет равенство значений без приведения типов.

## 8. Что такое Strict mode?

`Strict mode (Cтрогий режим)` вводит в код дополнительные проверки и ограничения для улучшения качества и безопасности кода. Включается директивой `"use strict";`.

## 9. Разница между function declaration и function expression?

`Function declaration (объявление функции)`: `function foo() { }` - имеет имя и доступна везде в текущей области видимости благодаря "всплытию".

`Function expression (функциональное выражение)`: `const foo = function() { }` - может быть анонимной или именованной, но доступно только после его объявления.

## 10. Разница между обычными функциями и стрелочными?

`Обычные функции` имеют собственное значение `this`, которое определяется в момент вызова функции. Они также имеют собственную область видимости для `arguments` и могут использоваться с `new`.

`Стрелочные функции` не имеют собственного `this`; вместо этого они захватывают значение `this` из окружающего контекста. Они не имеют `arguments` и не могут использоваться с `new`.

## 11. Что такое генераторы? Когда стоит использовать генераторы?

`Генераторы` — это функции, которые могут приостанавливать выполнение и возобновлять его позже. 
Они полезны для работы с последовательностями данных или асинхронными операциями, когда нужно получать значения по одному шагу за раз.

1. Синтаксис генератора:

   Генератор объявляется с помощью function* (звёздочка после function):

   ```javascript
    function* myGenerator() {
    yield 1;
    yield 2;
    yield 3;
    }
   ```

2. Оператор yield:

   yield приостанавливает выполнение генератора и возвращает значение:

   ```javascript
    const gen = myGenerator();
    
    console.log(gen.next()); // { value: 1, done: false }
    console.log(gen.next()); // { value: 2, done: false }
    console.log(gen.next()); // { value: 3, done: false }
    console.log(gen.next()); // { value: undefined, done: true }
   ```

   Свойства объекта:

   - value — текущее значение.

   - done — флаг завершения генератора.

3. Итерация через for...of

    Генераторы можно использовать как итераторы:

    ```javascript
    for (const value of myGenerator()) {
      console.log(value); // 1, 2, 3
    }
    ```

4. Асинхронные генераторы

   Генераторы могут быть асинхронными с async function* и работать с await:

    ```javascript
    async function* asyncGenerator() {
      yield await new Promise(resolve => setTimeout(() => resolve(1), 1000));
      yield await new Promise(resolve => setTimeout(() => resolve(2), 1000));
    }
    
    (async () => {
      for await (const value of asyncGenerator()) {
        console.log(value); // 1, 2 (с задержкой)
      }
    })();
    ```

## 13. Контекст выполнения (execution context)?

`Контекст выполнения (Execution Context)` — это среда, в которой выполняется текущий код, и которая управляет областью видимости переменных, определением this и порядком выполнения кода.

Основные типы контекстов выполнения:

1. Глобальный контекст выполнения:
    - Контекст по умолчанию для всего кода.
    - В браузере глобальный объект — window, в Node.js — global.
    - Все глобальные переменные и функции принадлежат этому контексту.

2. Контекст выполнения функции:
    - Создаётся при каждом вызове функции.
    - Внутри функции создаётся локальная область видимости для переменных и функций.
    - Каждый вызов функции — новый контекст выполнения.

Фазы контекста выполнения:

1. Фаза создания (Creation Phase):
   - Создаётся объект переменных (Lexical Environment):
       - Все переменные, функции и параметры определяются.
       - Происходит hoisting (подъём).
       - Для функции создаётся псевдомассив arguments.
   - Формируется цепочка областей видимости (Scope Chain)
       - Обеспечивает поиск переменных в текущем и внешних контекстах.
   - Устанавливается this:
       - В глобальном контексте — глобальный объект.
       - В функции — зависит от способа вызова.

2. Фаза исполнения (Execution Phase, выполнение):
    - Движок выполняет код построчно, используя созданное лексическое окружение и цепочку областей видимости.

## 14. Что такое область видимости (Scope)?

`Область видимости` — это область, ограничивающая доступ к переменным и функциям внутри себя, как бы инкапсулирующая их. 
Это также набор правил, по которым осуществляется поиск переменной.
Если переменной не существует в текущей области видимости, ее поиск производится выше, во внешней по отношению к текущей области видимости.
Если и во внешней области видимости переменная отсутствует, ее поиск продолжается вплоть до глобальной области видимости.
Если в глобальной области видимости переменная обнаружена, поиск прекращается, если нет — выбрасывается исключение.
Поиск осуществляется по ближайшим к текущей областям видимости и останавливается с нахождением переменной.
Это называется цепочкой областей видимости (Scope Chain).

Есть три типа областей видимости:

`Глобальная` — переменные и функции, объявленные в глобальном scope, доступны из любого места кода.

`Функциональная` — переменные, функции и параметры, объявленные внутри функции, доступны только внутри этой функции (`var` имеет эту область видимости).

`Блочная` — переменные, объявленные с помощью ключевых слов `let` и `const`, доступны только внутри блока `{}`, в котором были объявлены. `var` игнорирует блочную область и подчиняется функциональной.

## 15. Что такое поднятие (Hoisting)?

`Поднятие (Hoisting)` - это механизм, при котором объявления переменных и функций "поднимаются" в верхнюю часть их
области видимости во время компиляции.

## 16. Что такое замыкание (Closure)?

`Замыкание` — это способность функции во время создания запоминать ссылки на переменные и параметры, находящиеся в текущей области видимости.

## 17. Что обозначает this?

`this` — это ссылка на контекст выполнения функции. Его значение зависит от способа вызова функции, а не от того, где она была определена.

1. В глобальной области видимости

    ```javascript
    console.log(this); // В браузере: window
    ```

2. Внутри метода объекта

    this ссылается на объект, который вызвал метод:

    ```javascript
    const person = {
      name: 'Anton',
      greet() {
        console.log(`Hello, my name is ${this.name}`);
      }
    };
    
    person.greet(); // "Hello, my name is Anton"
    ```

3. В функциях-конструкторах и классах

    this ссылается на создаваемый экземпляр:
    
    ```javascript
    class Person {
      constructor(name) {
        this.name = name;
      }
      greet() {
        console.log(`Hello, my name is ${this.name}`);
      }
    }
    
    const anton = new Person('Anton');
    anton.greet(); // "Hello, my name is Anton"
    ```

4. В обычной функции

   В строгом режиме ('use strict') this будет undefined:

    ```javascript
    function showThis() {
      'use strict';
      console.log(this);
    }
    
    showThis(); // undefined
    ```

    Без строгого режима — глобальный объект (window в браузере).

5. В стрелочных функциях

    this берется из внешнего контекста, где была создана функция:
    
    ```javascript
    const obj = {
      name: 'Anton',
      greet: () => console.log(this.name)
    };
    
    obj.greet(); // undefined, потому что стрелочная функция не имеет собственного this
    
    ```

## 18. Что такое функции высшего порядка (Higher Order Functions)?

`Функция высшего порядка` — это функция, которая либо принимает другие функции в качестве аргументов, либо возвращает функцию.

## 19. Почему функции называют объектами первого класса?

`Функции являются объектами первого класса`, потому что их можно передавать как аргументы, возвращать из других
функций и присваивать переменным.

## 20. Что такое чистая функция?

`Чистая функция` - это функция, которая:

- Всегда возвращает один и тот же результат для одних и тех же аргументов.

- Не имеет побочных эффектов (не изменяет внешние переменные, не взаимодействует с DOM, не делает запросы и т.д.).

## 21. Как превратить любой тип данных в булевый? Перечислите ложные значения?

  Преобразование в булевый тип можно сделать через функцию `Boolean()` или оператор `!!`. Ложные
  значения: `false`, `0`, `-0`, `0n`, `""` (пустая строка), `null`, `undefined`, `NaN`.

## 22. Что такое шаблонные литералы (Template Literals)?

`Шаблонные литералы` — это строки, которые могут содержать выражения и многострочные тексты. Они создаются с помощью
обратных кавычек (`` ` ``). Например: `` `Hello, ${name}` ``. Это позволяет легко вставлять переменные и выполнять
выражения в строках.

## 23. Что такое итератор?

`Итератор` — это объект, который умеет последовательно возвращать элементы коллекции и отслеживать своё текущее положение внутри неё.

Итератор должен реализовывать метод next(), который возвращает объект с двумя свойствами:

- `value` — текущее значение;

- `done` — логическое значение, показывающее, завершена ли итерация (true — итерация завершена);

Чтобы объект был итерируемым (например, для for...of), он должен иметь метод Symbol.iterator.

Пример ручного создания итератора:

```javascript
const iterable = [10, 20, 30];

const iterator = iterable[Symbol.iterator]();

console.log(iterator.next()); // { value: 10, done: false }
console.log(iterator.next()); // { value: 20, done: false }
console.log(iterator.next()); // { value: 30, done: false }
console.log(iterator.next()); // { value: undefined, done: true }
```

Или использование через for...of:

```javascript
for (const value of iterable) {
  console.log(value); // 10, 20, 30
}
```

## 24. Методы объектов?

| Метод                               | Краткое описание                                                                    | Пример                                                                               |
| ----------------------------------- | ----------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------ |
| `Object.keys(obj)`                  | Возвращает массив ключей объекта                                                    | `Object.keys({a:1,b:2}) // ['a','b']`                                                |
| `Object.values(obj)`                | Возвращает массив значений объекта                                                  | `Object.values({a:1,b:2}) // [1,2]`                                                  |
| `Object.entries(obj)`               | Возвращает массив пар `[ключ, значение]`                                            | `Object.entries({a:1,b:2}) // [['a',1],['b',2]]`                                     |
| `Object.assign(target, ...sources)` | Копирует свойства из источников в цель                                              | `Object.assign({a:1},{b:2}) // {a:1,b:2}`                                            |
| `Object.freeze(obj)`                | "Замораживает" объект, запрещает добавлять/изменять/удалять свойства                | `const obj={a:1}; Object.freeze(obj); obj.a=2; console.log(obj.a) // 1`              |
| `Object.seal(obj)`                  | Запечатывает объект, нельзя добавлять/удалять свойства, можно изменять существующие | `const obj={a:1}; Object.seal(obj); obj.a=2; obj.b=3; console.log(obj) // {a:2}`     |
| `Object.create(proto)`              | Создает объект с указанным прототипом                                               | `const proto={g:'hi'}; const obj=Object.create(proto); console.log(obj.g) // 'hi'`   |
| `Object.hasOwnProperty(prop)`       | Проверяет, является ли свойство собственным                                         | `const obj={a:1}; obj.hasOwnProperty('a') // true`                                   |
| `Object.preventExtensions(obj)`     | Запрещает добавлять новые свойства                                                  | `const obj={a:1}; Object.preventExtensions(obj); obj.b=2; console.log(obj) // {a:1}` |
| `Object.isExtensible(obj)`          | Проверяет, можно ли добавлять свойства                                              | `const obj={}; Object.preventExtensions(obj); Object.isExtensible(obj) // false`     |
| `Object.isSealed(obj)`              | Проверяет, запечатан ли объект                                                      | `const obj={a:1}; Object.seal(obj); Object.isSealed(obj) // true`                    |
| `Object.isFrozen(obj)`              | Проверяет, заморожен ли объект                                                      | `const obj={a:1}; Object.freeze(obj); Object.isFrozen(obj) // true`                  |

## 25. Методы строк?

| Метод                               | Описание                                 | Пример                                                       |
| ----------------------------------- | ---------------------------------------- | ------------------------------------------------------------ |
| `length`                            | Длина строки                             | `"Hello".length // 5`                                        |
| `toUpperCase()`                     | Все символы в верхний регистр            | `"hello".toUpperCase() // "HELLO"`                           |
| `toLowerCase()`                     | Все символы в нижний регистр             | `"HELLO".toLowerCase() // "hello"`                           |
| `charAt(index)`                     | Символ по индексу                        | `"JavaScript".charAt(0) // "J"`                              |
| `charCodeAt(index)`                 | Код символа                              | `"A".charCodeAt(0) // 65`                                    |
| `codePointAt(index)`                | Unicode код символа                      | `"𠮷".codePointAt(0) // 134071`                              |
| `includes(substring)`               | Проверка наличия подстроки               | `"Hello".includes("ell") // true`                            |
| `startsWith(substring)`             | Начинается ли с подстроки                | `"Hello".startsWith("He") // true`                           |
| `endsWith(substring)`               | Заканчивается ли подстрокой              | `"Hello".endsWith("lo") // true`                             |
| `indexOf(substring)`                | Индекс первого вхождения                 | `"Hello".indexOf("l") // 2`                                  |
| `lastIndexOf(substring)`            | Индекс последнего вхождения              | `"Hello".lastIndexOf("l") // 3`                              |
| `slice(start, end)`                 | Вырезает часть строки                    | `"Hello".slice(1,4) // "ell"`                                |
| `substring(start, end)`             | Аналог slice, без отрицательных индексов | `"Hello".substring(1,4) // "ell"`                            |
| `substr(start, length)`             | Вырезает подстроку по старту и длине     | `"Hello".substr(1,3) // "ell"`                               |
| `replace(searchValue, newValue)`    | Заменяет подстроку                       | `"Hello".replace("H", "J") // "Jello"`                       |
| `replaceAll(searchValue, newValue)` | Заменяет все вхождения                   | `"aabb".replaceAll("a","x") // "xxbb"`                       |
| `split(separator)`                  | Разбивает на массив                      | `"a,b,c".split(",") // ["a","b","c"]`                        |
| `concat(...strings)`                | Объединяет строки                        | `"Hello".concat(" ","World") // "Hello World"`               |
| `trim()`                            | Удаляет пробелы по краям                 | `"  hi  ".trim() // "hi"`                                    |
| `trimStart()` / `trimLeft()`        | Удаляет пробелы в начале                 | `"  hi".trimStart() // "hi"`                                 |
| `trimEnd()` / `trimRight()`         | Удаляет пробелы в конце                  | `"hi  ".trimEnd() // "hi"`                                   |
| `repeat(count)`                     | Повторяет строку                         | `"Hi!".repeat(3) // "Hi!Hi!Hi!"`                             |
| `localeCompare(str)`                | Сравнение с учётом локали                | `"a".localeCompare("b") // -1`                               |
| `match(regexp)`                     | Возвращает массив совпадений             | `"abc123".match(/\d+/) // ["123"]`                           |
| `matchAll(regexp)`                  | Итератор всех совпадений                 | `[... "abc123def456".matchAll(/\d+/g)] // [["123"],["456"]]` |
| `search(regexp)`                    | Индекс первого совпадения                | `"abc123".search(/\d/) // 3`                                 |
| `padStart(targetLength, padString)` | Дополняет строку слева                   | `"5".padStart(3,"0") // "005"`                               |
| `padEnd(targetLength, padString)`   | Дополняет строку справа                  | `"5".padEnd(3,"0") // "500"`                                 |
| `normalize(form)`                   | Unicode нормализация                     | `"e\u0301".normalize() // "é"`                               |
| `toString()`                        | Преобразует в строку                     | `(123).toString() // "123"`                                  |
| `toLocaleString()`                  | Преобразует с учётом локали              | `(12345).toLocaleString("de-DE") // "12.345"`                |

## 26. Методы массивов? Мутирующие методы массива?

| Метод                                  | Мутирует массив? | Краткое описание                                                 | Пример                                                            |
| -------------------------------------- | ---------------- | ---------------------------------------------------------------- | ----------------------------------------------------------------- |
| `push(...items)`                       | ✅ Да             | Добавляет элементы в конец массива                               | `let arr=[1,2]; arr.push(3); console.log(arr) // [1,2,3]`         |
| `pop()`                                | ✅ Да             | Удаляет последний элемент и возвращает его                       | `let arr=[1,2,3]; arr.pop() // 3`                                 |
| `shift()`                              | ✅ Да             | Удаляет первый элемент и возвращает его                          | `let arr=[1,2,3]; arr.shift() // 1`                               |
| `unshift(...items)`                    | ✅ Да             | Добавляет элементы в начало массива                              | `let arr=[2,3]; arr.unshift(1); console.log(arr) // [1,2,3]`      |
| `splice(start, deleteCount, ...items)` | ✅ Да             | Удаляет/добавляет элементы по индексу                            | `let arr=[1,2,3]; arr.splice(1,1,4); console.log(arr) // [1,4,3]` |
| `sort(compareFn)`                      | ✅ Да             | Сортирует массив на месте                                        | `[3,1,2].sort() // [1,2,3]`                                       |
| `reverse()`                            | ✅ Да             | Переворачивает порядок элементов                                 | `[1,2,3].reverse() // [3,2,1]`                                    |
| `fill(value, start?, end?)`            | ✅ Да             | Заполняет массив значением                                       | `new Array(3).fill(0) // [0,0,0]`                                 |
| `copyWithin(target, start?, end?)`     | ✅ Да             | Копирует часть массива внутри массива                            | `[1,2,3,4].copyWithin(0,2) // [3,4,3,4]`                          |
| `concat(...arrays)`                    | ❌ Нет            | Создает новый массив, объединяя массивы                          | `[1,2].concat([3,4]) // [1,2,3,4]`                                |
| `slice(start?, end?)`                  | ❌ Нет            | Возвращает часть массива в новом массиве                         | `[1,2,3].slice(1,3) // [2,3]`                                     |
| `map(fn)`                              | ❌ Нет            | Применяет функцию к каждому элементу                             | `[1,2,3].map(x=>x*2) // [2,4,6]`                                  |
| `filter(fn)`                           | ❌ Нет            | Возвращает новый массив с элементами, удовлетворяющими условию   | `[1,2,3].filter(x=>x>1) // [2,3]`                                 |
| `reduce(fn, initial)`                  | ❌ Нет            | Вычисляет одно значение на основе элементов                      | `[1,2,3].reduce((a,b)=>a+b,0) // 6`                               |
| `reduceRight(fn, initial)`             | ❌ Нет            | То же самое, но справа налево                                    | `[1,2,3].reduceRight((a,b)=>a-b,0) // 0-3= -3 ...`                |
| `forEach(fn)`                          | ❌ Нет            | Выполняет функцию для каждого элемента                           | `[1,2,3].forEach(x=>console.log(x)) // 1 2 3`                     |
| `find(fn)`                             | ❌ Нет            | Первый элемент, удовлетворяющий условию                          | `[1,2,3].find(x=>x>1) // 2`                                       |
| `findIndex(fn)`                        | ❌ Нет            | Индекс первого элемента, удовлетворяющего условию                | `[1,2,3].findIndex(x=>x>1) // 1`                                  |
| `some(fn)`                             | ❌ Нет            | Проверяет, есть ли хотя бы один элемент, удовлетворяющий условию | `[1,2,3].some(x=>x>2) // true`                                    |
| `every(fn)`                            | ❌ Нет            | Проверяет, все ли элементы удовлетворяют условию                 | `[1,2,3].every(x=>x>0) // true`                                   |
| `includes(value)`                      | ❌ Нет            | Проверяет наличие элемента                                       | `[1,2,3].includes(2) // true`                                     |
| `indexOf(value, fromIndex?)`           | ❌ Нет            | Индекс первого совпадения                                        | `[1,2,3,2].indexOf(2) // 1`                                       |
| `lastIndexOf(value, fromIndex?)`       | ❌ Нет            | Индекс последнего совпадения                                     | `[1,2,3,2].lastIndexOf(2) // 3`                                   |
| `join(separator?)`                     | ❌ Нет            | Преобразует массив в строку                                      | `[1,2,3].join("-") // "1-2-3"`                                    |
| `flat(depth?)`                         | ❌ Нет            | Разворачивает вложенные массивы                                  | `[1,[2,[3]]].flat(2) // [1,2,3]`                                  |
| `flatMap(fn)`                          | ❌ Нет            | map + flat(1)                                                    | `[1,2].flatMap(x=>[x,x*2]) // [1,2,2,4]`                          |
| `toString()`                           | ❌ Нет            | Преобразует массив в строку                                      | `[1,2,3].toString() // "1,2,3"`                                   |
| `toLocaleString()`                     | ❌ Нет            | Преобразует с учётом локали                                      | `[123456].toLocaleString("de-DE") // "123.456"`                   |
| `keys()`                               | ❌ Нет            | Итератор по индексам                                             | `Array.from([1,2].keys()) // [0,1]`                               |
| `values()`                             | ❌ Нет            | Итератор по значениям                                            | `Array.from([1,2].values()) // [1,2]`                             |
| `entries()`                            | ❌ Нет            | Итератор пар [ключ, значение]                                    | `Array.from([1,2].entries()) // [[0,1],[1,2]]`                    |
| `Array.from(iterable)`                 | ❌ Нет            | Новый массив из итерируемого объекта                             | `Array.from("abc") // ["a","b","c"]`                              |
| `Array.isArray(obj)`                   | ❌ Нет            | Проверка, является ли объект массивом                            | `Array.isArray([1,2]) // true`                                    |
| `Array.of(...items)`                   | ❌ Нет            | Новый массив из аргументов                                       | `Array.of(1,2,3) // [1,2,3]`                                      |

## 27. Разница между .call(), .apply() и bind()?

| Метод      | Что делает                                                                                                            | Пример                                   |
| ---------- |-----------------------------------------------------------------------------------------------------------------------|------------------------------------------|
| `.call()`  | Вызывает функцию с указанным `this` и аргументами **по отдельности**                                                  | `fn.call(obj, arg1, arg2)`               |
| `.apply()` | Вызывает функцию с указанным `this` и аргументами **в виде массива**                                                  | `fn.apply(obj, [arg1, arg2])`            |
| `.bind()`  | Возвращает **новую функцию** с указанным `this` и, опционально, с **частично переданными аргументами по отдельности** | `const newFn = fn.bind(obj, arg1, arg2)` |

## 28. Что такое IIFE?

`IIFE (Immediately Invoked Function Expression)` — это функция, которая определяется и немедленно вызывается сразу после своего создания, предотвращает "загрязнение" глобального пространства имен:

```javascript
(function() { /* code */ })();
```

## 29. Что такое псевдомассив arguments?

`arguments `— это коллекция аргументов, передаваемых функции. 
Он имеет свойство length и поддерживает обращение по индексу к элементам, но не является массивом, из-за чего не имеет методов forEach, reduce, filter, map и так далее.

В стрелочных функциях объект arguments не работает.

## 30. Разница между host-объектами и нативными объектами?

| Тип объекта      | Определение                                                           | Примеры                                                                            |
| ---------------- | --------------------------------------------------------------------- | ---------------------------------------------------------------------------------- |
| **Нативные**     | Встроенные объекты JavaScript, реализованные самим движком            | `Object`, `Array`, `Function`, `Date`                                              |
| **Host-объекты** | Предоставляются средой выполнения (не самим JS), зависят от окружения | В браузере: `window`, `document`, `XMLHttpRequest`; в Node.js: `process`, `Buffer` |

## 31. Почему результат сравнения 2х объектов это false? Как сравнить два объекта?

Объекты сравниваются по ссылке, а не по значению.

Даже если два объекта содержат одинаковые данные, они разные по ссылке, и сравнение obj1 === obj2 вернёт false.

```javascript
const a = { name: 'Alice' };
const b = { name: 'Alice' };

console.log(a === b); // false
```

Как сравнить два объекта

1. Поверхностное сравнение (Shallow Compare)

    Сравнивает только верхний уровень свойств.
    
    ```javascript
    function shallowEqual(obj1, obj2) {
      const keys1 = Object.keys(obj1);
      const keys2 = Object.keys(obj2);
    
      if (keys1.length !== keys2.length) return false;
    
      for (let key of keys1) {
        if (obj1[key] !== obj2[key]) return false;
      }
    
      return true;
    }
    ```

2. Глубокое сравнение (Deep Compare)

    Сравнивает все вложенные объекты рекурсивно.
    
    ```javascript
    function deepEqual(obj1, obj2) {
      if (obj1 === obj2) return true;
    
      if (typeof obj1 !== 'object' || typeof obj2 !== 'object' || !obj1 || !obj2) {
        return false;
      }
    
      const keys1 = Object.keys(obj1);
      const keys2 = Object.keys(obj2);
    
      if (keys1.length !== keys2.length) return false;
    
      for (let key of keys1) {
        if (!keys2.includes(key) || !deepEqual(obj1[key], obj2[key])) return false;
      }
    
      return true;
    }
    ```

3. С помощью `JSON.stringify`

    ```javascript
    const areEqual = JSON.stringify(obj1) === JSON.stringify(obj2);
    ```
    
    - Плюсы: Просто и быстро

    - Минусы: Порядок свойств имеет значение, не работает с функциями, undefined, Date и др.

4. С помощью библиотек

   - Lodash

    ```javascript
    const _ = require('lodash');
    _.isEqual(obj1, obj2);
    ```
    
    - fast-deep-equal
    
    ```javascript
    const deepEqual = require('fast-deep-equal');
    deepEqual(obj1, obj2);
    ```
    
    - Плюсы: мощные и гибкие, глубокое сравнение любых объектов

    - Минусы: требуется установка библиотеки

## 32. Что такое NaN? Как определить, что значение равно NaN?

`NaN (Not-a-Number)` - специальное значение, которое указывает, что результат операции не является числом.

Определить `NaN` можно с помощью функции `isNaN()` (Преобразует переданное значение в число, если это возможно, и затем проверяет, является ли оно NaN) или метода `Number.isNaN()` (Проверяет только те значения, которые уже являются NaN, и не выполняет никакого преобразования).

## 33. Что такое объектная обертка (Wrapper Objects)?

Объектные обертки (`String`, `Number`, `Boolean`, `Symbol` и `BigInt`) позволяют работать с примитивными значениями как с объектами,
предоставляя методы и свойства.

## 34. Как работает Boxing/Unboxing?

`Boxing` - это процесс оборачивания примитива в объектную обертку, например, при доступе к свойствам или методам
примитивного значения.

`Unboxing` - обратный процесс, когда объектная обертка преобразуется обратно в примитив.

## 35. Как создать объект?

- Литерал объекта: `{ key: value }`
- `new Object()`
- `Object.create(proto)`

## 36. Дескрипторы?

Каждое свойство объекта имеет:

| Атрибут        | Значение     | Описание                                            |
| -------------- | ------------ | --------------------------------------------------- |
| `value`        | любое        | Значение свойства                                   |
| `writable`     | `true/false` | Можно ли изменить значение                          |
| `enumerable`   | `true/false` | Участвует ли в переборе (for...in, Object.keys)     |
| `configurable` | `true/false` | Можно ли удалить свойство или изменить его атрибуты |

Если configurable: false, то флаги изменить нельзя, свойство удалить нельзя, но значение можно изменить (если writable: true).

Получение дескриптора:

```javascript
let user = { name: "John" };
let descriptor = Object.getOwnPropertyDescriptor(user, 'name');
console.log(descriptor);
/* 
{
  value: "John",
  writable: true,
  enumerable: true,
  configurable: true
}
*/
```

Изменение или создание свойства с дескриптором:

```javascript
Object.defineProperty(obj, propertyName, descriptor);
```

- obj — объект

- propertyName — имя свойства

- descriptor — объект с атрибутами

```javascript
Object.defineProperty(user, 'name', { writable: false });
user.name = 'Alice'; // не изменится
```

Определение нескольких свойств сразу:

```javascript
Object.defineProperties(user, {
  name: { value: "John", writable: false },
  surname: { value: "Smith", writable: false }
});
```

Получение всех дескрипторов:

```javascript
Object.getOwnPropertyDescriptors(user);
```

## 37. Для чего используется ключевое слово new?

`new` используется для создания нового объекта (экземпляра функции-конструктора или класса).

Что делает `new`:

1. Создаёт новый пустой объект.

2. Привязывает к нему this, чтобы ссылки внутри функции-конструктора указывали на этот объект.

3. Создаёт прототипную связь: объект наследует свойства и методы конструктора через [[Prototype]] (или __proto__).

4. Возвращает объект this, если функция не возвращает другой объект явно.

```javascript
function Person(name) {
  this.name = name;
}

const user = new Person('Alice');
console.log(user.name); // "Alice"
console.log(user instanceof Person); // true
```

## 38. Что такое Set, Map, WeakMap и WeakSet?

`Map` — коллекция пар "ключ-значение", где ключи могут быть любого типа. Порядок элементов в `Map` сохраняется.

Методы и свойства:

- `new Map()` – создаёт коллекцию.
- `Map.prototype.set(key, value)` – записывает по ключу key значение value.
- `Map.prototype.get(key)` – возвращает значение по ключу или undefined, если ключ key отсутствует.
- `Map.prototype.has(key)` – возвращает true, если ключ key присутствует в коллекции, иначе false.
- `Map.prototype.delete(key)` – удаляет элемент (пару «ключ/значение») по ключу key.
- `Map.prototype.clear()` – очищает коллекцию от всех элементов.
- `Map.prototype.size` – возвращает текущее количество элементов.

Для перебора коллекции Map:

- `Map.prototype.keys()` – возвращает итерируемый объект по ключам,
- `Map.prototype.values()` – возвращает итерируемый объект по значениям,
- `Map.prototype.entries()` – возвращает итерируемый объект по парам вида [ключ, значение], этот вариант используется
  по умолчанию в for..of.

`Set` — коллекция уникальных значений. Значения в Set могут быть любого типа и не повторяются.

Его основные методы это:

- `new Set(iterable)` – создаёт Set, и если в качестве аргумента был предоставлен итерируемый объект (обычно это
  массив), то копирует его значения в новый Set.
- `Set.prototype.add(value)` – добавляет значение (если оно уже есть, то ничего не делает), возвращает тот же объект
  Set.
- `Set.prototype.delete(value)` – удаляет значение, возвращает true, если value было в множестве на момент вызова,
  иначе false.
- `Set.prototype.has(value)` – возвращает true, если значение присутствует в множестве, иначе false.
- `Set.prototype.clear()` – удаляет все имеющиеся значения.
- `Set.prototype.size` – возвращает количество элементов в множестве.

Для перебора коллекции Set:

- `Set.prototype.keys()` – возвращает перебираемый объект для значений,
- `Set.prototype.values()` – то же самое, что и set.keys(), присутствует для обратной совместимости с Map,
- `Set.prototype.entries()` – возвращает перебираемый объект для пар вида [значение, значение], присутствует для
  обратной совместимости с Map.

`WeakMap` — аналог `Map`, но ключи должны быть объектами, и они не предотвращают сборку мусора. Это позволяет автоматически очищать неиспользуемые ключи.

`WeakSet` — аналог `Set`, но элементы могут быть только объектами, и они не предотвращают сборку мусора.

`WeakSet и WeakMap` – это специальные структуры данных, которые отличаются особенностью хранения ссылок на объекты.

В обычных `Set и Map` хранятся сильные ссылки на объекты. Это значит, что пока существует ссылка на объект в этих структурах, сборщик мусора не удалит этот объект из памяти, даже если больше нигде в коде нет ссылок на него.

И напротив, в `WeakSet` и `WeakMap` хранятся слабые ссылки. Это означает, что если объект, на который есть ссылка в этих структурах, больше недоступен в коде (т.е. нигде больше нет сильных ссылок на него), то сборщик мусора может удалить этот объект из памяти, даже если в WeakSet или WeakMap все еще есть ссылка на него. Таким образом, использование слабых ссылок позволяет не держать в памяти ненужные больше объекты и экономить память.

Кроме того, в `WeakMap` в качестве ключей могут использоваться только объекты, а не примитивные значения. А в `WeakSet` хранятся только объекты, без ключей.

## 39. Операторы «И», «ИЛИ» и «Нулевого слияния» (&&, || и ??)?

`&& (И)` возвращает первое ложное значение или последнее истинное.

`|| (ИЛИ)` возвращает первое истинное значение или последнее ложное.

`?? (оператор нулевого слияния)` возвращает первое значение, не равное null или undefined; если таких нет — возвращается последнее значение.

## 41. Расскажите об операторе Optional Chaining (?.)?

`Оператор Optional Chaining (?.)` позволяет безопасно обращаться к вложенным свойствам объекта, не вызывая ошибку,
если одно из промежуточных свойств `null` или `undefined`. Например, `obj?.property?.subProperty`.

## 43. Разница между глубокой (deep) и поверхностной (shallow) копиями объекта? Как сделать каждую из них?

`Поверхностная копия (shallow)` копирует только верхний уровень объекта. Вложенные объекты остаются ссылками на исходный объект. Например, с помощью `Object.assign()` или оператора
распространения `{ ...obj }`.

```javascript
const obj = { a: 1, b: { c: 2 } };
const shallowCopy = { ...obj };

shallowCopy.b.c = 42;
console.log(obj.b.c); // 42 — вложенный объект изменился в исходном объекте
```

`Глубокая копия (deep)` копирует все уровни вложенности объекта. Например, с помощью `JSON.parse(JSON.stringify(obj))` или
библиотек вроде `lodash` (`_.cloneDeep(obj)`).

```javascript
const obj = { a: 1, b: { c: 2 } };
const deepCopy = JSON.parse(JSON.stringify(obj));

deepCopy.b.c = 42;
console.log(obj.b.c); // 2 — исходный объект не изменился
```

## 44. Как передаются параметры в функцию: по ссылке или по значению?

Примитивные типы передаются `по значению`, объекты передаются `по ссылке`.

## 45. Что такое прототип объекта?

`Прототип объекта` - это объект, от которого другой объект наследует свойства и методы.

## 46. Что такое прототипное наследование? Как создать объект без прототипа?

`Прототипное наследование` - механизм, при котором объекты могут наследовать
свойства и методы от другого объекта (прототипа).

Объект без прототипа можно создать с помощью `Object.create(null)`.

## 42. Как определить наличие свойства в объекте? Разница между оператором in и методом .hasOwnProperty()?

`in` проверяет наличие свойства в объекте и его прототипах.

`.hasOwnProperty()` проверяет наличие свойства только в самом объекте.

## 48. Типы ошибок?

🔹 Общий объект ошибок
- Конструктор: `Error`

```javascript
const commonError = new Error('Общая ошибка. Проверьте код');
console.log(commonError.message); // 'Общая ошибка. Проверьте код'
console.log(commonError.name);    // 'Error'
```

- `message` — описание ошибки

- `name` — тип ошибки

🔹 Встроенные типы ошибок

| Ошибка           | Описание                                               | Пример                                                   |
| ---------------- | ------------------------------------------------------ | -------------------------------------------------------- |
| `SyntaxError`    | Синтаксическая ошибка                                  | `console.log(; ) // SyntaxError`                         |
| `ReferenceError` | Обращение к несуществующей переменной                  | `console.log(name) // ReferenceError`                    |
| `TypeError`      | Нарушение типа, некорректная операция                  | `null.length // TypeError`<br>`undefined() // TypeError` |
| `RangeError`     | Значение выходит за допустимый диапазон                | `new Array(1e12) // RangeError`                          |
| `URIError`       | Некорректная работа с URI                              | `decodeURIComponent('%') // URIError`                    |
| `EvalError`      | Ошибка при использовании `eval()` (редко используется) | `eval('console.log(null.length)')`                       |


## 49. Разница между typeof и instanceof?

`typeof` возвращает строку, указывающую тип примитива или объекта.

```javascript
typeof 42;           // "number"
typeof "hello";      // "string"
typeof true;         // "boolean"
typeof {};           // "object"
typeof null;         // "object" (историческая особенность)
typeof function(){}; // "function"
```

`instanceof` проверяет, является ли объект экземпляром определенного конструктора.

```javascript
[] instanceof Array;        // true
// {} instanceof Object;  true
new Date() instanceof Date; // true
42 instanceof Number;       // false, примитивы не проходят
```

## 50. Что такое регулярное выражение (Regular Expression)? Какие методы используются в регулярных выражениях?

`Регулярное выражение (RegExp, или regex)` — это шаблон, описывающий, какие строки нужно найти или обработать.

Используется для: поиска, замены, проверки строк и валидации данных.

Основные элементы RegExp:

1. `Литералы` — простые символы, которые соответствуют самим себе (a, b, 1).

2. `Специальные символы`:

   - `.` — любой символ, кроме новой строки

   - `*` — 0 или более повторений предыдущего символа

   - `+` — 1 или более повторений предыдущего символа

   - `?` — 0 или 1 повторение предыдущего символа

   - `^` — начало строки

   - `$` — конец строки

   - `[]` — класс символов (например, [a-z] — любой символ от a до z)

   - `()` — группировка (например, (abc) соответствует строке "abc")

   - `|` — логическое «или» (например, a|b соответствует либо "a", либо "b")

3. `Экранирование` — для использования спецсимволов как литералов: \. соответствует точке ..

Методы для работы с регулярными выражениями:

| Метод              | Описание                                    | Пример                                       |
| ------------------ | ------------------------------------------- | -------------------------------------------- |
| `RegExp`           | Конструктор                                 | `const regex = new RegExp('abc');`           |
| `String.match()`   | Возвращает массив совпадений или `null`     | `'abcdef'.match(/abc/) // ['abc']`           |
| `String.replace()` | Заменяет совпадения                         | `'abcdef'.replace(/abc/, 'xyz') // 'xyzdef'` |
| `String.search()`  | Возвращает индекс первого совпадения или -1 | `'abcdef'.search(/abc/) // 0`                |
| `String.split()`   | Делит строку по шаблону                     | `'a,b,c'.split(/,/) // ['a','b','c']`        |
| `RegExp.test()`    | Проверяет наличие совпадения (true/false)   | `/abc/.test('abcdef') // true`               |

## 51. Что такое полифил (polyfill)?

`Полифил` — это код, который добавляет поддержку новых функций и методов в старые браузеры, где они не реализованы.

Цель: позволить разработчикам использовать современные возможности JavaScript, не дожидаясь, пока все пользователи обновят браузеры.

Пример: метод Array.prototype.includes

```javascript
if (!Array.prototype.includes) {
    Array.prototype.includes = function(element) {
        return this.indexOf(element) !== -1;
    };
}
```

- Проверяем, есть ли метод.

- Если нет — добавляем реализацию.

## 52. Типы операторов?

- Арифметические: `+`, `-`, `*`, `/`, `%`
- Сравнения: `==`, `===`, `!=`, `!==`, `>`, `<`, `>=`, `<=`
- Логические: `&&`, `||`, `!`
- Присваивания: `=`, `+=`, `-=`, `*=`, `/=`
- Побитовые: `&`, `|`, `^`, `~`, `<<`, `>>`, `>>>`
- Специальные: `typeof`, `instanceof`, `new`, `delete`, `void`, `in`

## 53. Правила задания имён для переменных и функций?

1. Начало имени

   - Имя должно начинаться с буквы, знака доллара $ или подчёркивания _.

   - Нельзя начинать с цифры.

2. Состав имени

   - Может содержать буквы, цифры, $ и _.

   - Чувствительно к регистру (myVar ≠ MyVar).

3. Читаемость

   - Имена должны быть понятными и описательными.

4. Запрещённые слова

   - Нельзя использовать зарезервированные слова (if, for, class, return и т.д.).

✅ Пример корректных имён:

```javascript
let name;
let $price;
let _count;
let totalAmount;
```

❌ Некорректные имена:

```javascript
// let 1name;  начинается с цифры
// let for;  зарезервированное слово
```

## 54. Разница между явным и неявным преобразованием (Implicit and Explicit Coercion)?

`Явное преобразование`: программист явно указывает преобразование типа (`Number()`, `String()`, `Boolean()`).

`Неявное преобразование`: JavaScript автоматически преобразует типы в процессе выполнения.

## 55. Что такое каррирование и композиция?

`Каррирование` — это техника функционального программирования, которая преобразует функцию с несколькими аргументами в последовательность функций, каждая из которых принимает по одному аргументу.

```javascript
// Обычная функция
function add(x, y) {
    return x + y;
}

// Каррированная функция
function curriedAdd(x) {
    return function(y) {
        return x + y;
    };
}

const addFive = curriedAdd(5);
console.log(addFive(3)); // 8

// const curriedAdd = x => y => x + y; короткий современный вариант через стрелочные функции
```

`Композиция` — это объединение нескольких функций в одну, где результат одной передаётся следующей.

```javascript
const compose = (...fns) => x => fns.reduceRight((v, f) => f(v), x);

const toUpper = str => str.toUpperCase();
const exclaim = str => str + '!';

const shout = compose(exclaim, toUpper);
console.log(shout('hello')); // "HELLO!"
```

## 56. Как работает «сборщик мусора»?

`Сборщик мусора (Garbage Collector, GC)` — это механизм, который автоматически освобождает память, удаляя объекты, на которые больше нет ссылок и которые не используются.

🔹 Основные принципы

1. Отслеживание ссылок (Reference Counting / Reachability)

   - Объект считается живым, если к нему есть доступ через глобальные переменные, стек вызовов или цепочку объектов.

   - Если объект недостижим (нет ссылок), сборщик мусора может его удалить.

2. Алгоритмы сборки мусора

   - Mark-and-Sweep (Пометка и удаление):

     1. Сборщик проходит по всем доступным объектам и помечает их как “живые”.
    
     2. Все непомеченные объекты считаются “мёртвыми” и удаляются из памяти.
    
    - Другие техники: копирование, генерационная сборка (часто в современных движках для оптимизации).

🔹 Особенности

- Сборщик мусора работает автоматически, программисту не нужно явно освобождать память.

- Важно избегать утечек памяти, чтобы GC мог корректно очищать объекты.

## 57. Что такое утечки памяти? Основные типы утечек памяти?

`Утечка памяти` — это ситуация, когда программа не освобождает память после использования объектов, что может привести к её исчерпанию и снижению производительности.

Основные типы утечек:

1. Задержки ссылок (Reference Retention)

   - Объекты остаются доступными из других объектов, хотя больше не нужны.

   - Часто связано с глобальными переменными или переменными в замыканиях.

2. Замыкания (Closures)

   - Функции сохраняют ссылки на переменные внешней области видимости.

     - Если функция живёт долго, объекты, на которые есть ссылки, не освобождаются.

3. Обработчики событий (Event Handlers)

   - Если обработчики не удаляются после использования, они удерживают ссылки на DOM-элементы или объекты.

4. Неочищенные таймеры и интервалы (Uncleared Timers / Intervals)

   - Таймеры (setTimeout, setInterval), которые не очищаются, удерживают функции и связанные объекты.

5. Кэширование (Caching)

   - Если объекты кэшируются и кэш не очищается, память постепенно расходуется на ненужные данные.

6. Неосвобождённые DOM-элементы

   - Созданные, но не удалённые элементы DOM остаются в памяти, даже если они не видимы на странице.

7. Ошибки в библиотеках и фреймворках

   - Некоторые библиотеки могут содержать свои утечки памяти из-за неправильного управления объектами.

## 58. Почему typeof null возвращает object?

`typeof null` возвращает `object` по историческим причинам.

Когда JavaScript создавался, значение null внутренне представлялось как "null pointer" и имело тип 0 в машинном представлении.

Функция typeof смотрела на внутренний тег типа, и поэтому null ошибочно определялся как объект.

Из-за обратной совместимости это поведение сохранилось, и менять его уже нельзя, иначе сломались бы миллионы сайтов.

Для проверки null всегда используйте строгое сравнение ===.

```javascript
function isNull(value) {
  return value === null;
}

console.log(isNull(null)); // true
console.log(isNull({}));   // false
```

## 59. Что такое модули, import/export?

`ES6 модули` позволяют организовывать код в модули, которые могут экспортировать (`export`) и импортировать (`import`) функциональность.

Модули позволяют объединять (использовать) код из разных файлов и избавляют нас от необходимости держать весь код в одном большом файле.

## 60. Proxy и Reflect?

🔹`Proxy` — это обёртка вокруг объекта, которая позволяет перехватывать и изменять поведение операций с этим объектом.

```javascript
let proxy = new Proxy(target, {
  /* ловушки (traps) */
});
```

Основная идея:

Если операция не перехвачена, она автоматически перенаправляется на target.

Если есть «ловушка» (trap), то она выполняется вместо обычного поведения.

Часто используемые ловушки:

- `get` — чтение свойства

- `set` — запись свойства

- `deleteProperty` — удаление свойства

- `apply` — вызов функции

- `construct` — вызов через new

```javascript
let user = { name: "Вася" };

let proxy = new Proxy(user, {
  get(target, prop) {
    console.log(`GET ${prop}`);
    return target[prop];
  },
  set(target, prop, value) {
    console.log(`SET ${prop} = ${value}`);
    target[prop] = value;
    return true;
  }
});

proxy.name;      // GET name
proxy.name = "Петя"; // SET name = Петя
```

🔹`Reflect` — это встроенный объект, который предоставляет методы для обращения к внутренним операциям,
таким как чтение, запись, удаление свойств и вызов функций.
Методы Reflect соответствуют ловушкам Proxy (один к одному).

```javascript
let user = {};

Reflect.set(user, 'name', 'Вася');
console.log(Reflect.get(user, 'name')); // Вася
let user = {};

Reflect.set(user, 'name', 'Вася');
console.log(Reflect.get(user, 'name')); // Вася
```

Типичный случай использования:

Внутри прокси ловушка вызывает Reflect, чтобы “прозрачно” передать действие оригинальному объекту:

```javascript
let user = { name: "Вася" };

let proxy = new Proxy(user, {
  get(target, prop, receiver) {
    console.log(`GET ${prop}`);
    return Reflect.get(target, prop, receiver);
  },
  set(target, prop, value, receiver) {
    console.log(`SET ${prop} = ${value}`);
    return Reflect.set(target, prop, value, receiver);
  }
});
```

Ключевые моменты

- Proxy позволяет изменять поведение объектов.

- Reflect — удобный способ вызвать стандартное поведение внутри ловушек.

- Для каждой ловушки Proxy есть соответствующий метод в Reflect.

- Некоторые вещи нельзя проксировать (встроенные слоты, приватные поля, ===).

- Прокси немного медленнее обычных объектов.

[LearnJS](https://learn.javascript.ru/proxy#reflect)

## 61. Разница постфикса и префикса инкремента и декремента?

`Префиксный инкремент/декремент (++x или --x):` сначала изменяет значение переменной, затем возвращает изменённое значение.

`Постфиксный инкремент/декремент (x++ или x--):` сначала возвращает текущее значение переменной, затем изменяет её значение.

## 62. Разница между синхронными и асинхронными функциями?

`Синхронные функции` выполняются последовательно: следующая строка кода не выполняется, пока текущая функция не завершится.

`Асинхронные функции` позволяют запускать операции, которые завершатся позже, не блокируя основной поток выполнения. 
Код после вызова асинхронной функции выполняется сразу, а результат асинхронной операции обрабатывается позже (через `callback`, `Promise` или `await`).

## 63. Что такое AJAX?

`AJAX (Asynchronous JavaScript and XML)` — это подход к разработке веб-приложений, позволяющий обмениваться данными с сервером асинхронно,
без перезагрузки страницы. AJAX использует объект XMLHttpRequest (или современный метод fetch()) для отправки и получения данных с сервера.

## 64. Что такое fetch()?

`fetch()` — это встроенная функция, используемая для выполнения HTTP-запросов.
Возвращает промис, который разрешается в ответ на запрос.

## 65. Что такое JSON? Отличие от XML?

`JSON (JavaScript Object Notation)` - это формат для обмена данными между клиентом и сервером, основанный на JavaScript-объектах. Его можно парсить и сериализовать с помощью `JSON.parse()` и `JSON.stringify()`.

Различия JSON и XML:

- `JSON (JavaScript Object Notation):` легковесный формат для хранения и передачи данных, легко
  читается человеком и машиной.
- `XML (eXtensible Markup Language):` более сложный формат для хранения и передачи данных, использующий разметку
  для определения структуры.

## 66. Что такое цикл событий (Event Loop)? Как он работает? Разница между микро и макрозадачами?

`Цикл событий (Event Loop)` — это механизм, который позволяет JavaScript оставаться однопоточным, но при этом эффективно выполнять асинхронный код без блокировки основного потока.

Основные компоненты JavaScript-окружения:

1. Call Stack (Стек вызовов)

   - Хранит выполняемый код (основной поток), работает по принципу LIFO (последним вошёл — первым вышел).

   - Когда функция вызывается — помещается в стек; после выполнения — удаляется.

2. Heap (Куча)

   - Область памяти для объектов и других ссылочных данных, которая хранит данные динамического размера: объекты и массивы, на которые стек содержит лишь ссылки.

3. Web APIs / Node APIs

   - Среда выполнения (браузер или Node.js) предоставляет асинхронные возможности, которые не выполняются в JS-движке напрямую: таймеры, сетевые запросы, события DOM.

   - Когда операция завершается, её колбэк попадает в очередь задач соответствующего типа.

4. Очереди задач, работают по принципу FIFO (первым вошел - первым вышел)

   - Микрозадачи (Micro Task Queue) — выполняются внутри JS-движка, без участия внешней среды сразу после опустошения стека.
     Примеры: Promise.then/catch/finally, queueMicrotask, process.nextTick.

   - Макрозадачи (Macro Task Queue) — колбэки асинхронных операций среды, которые будут выполнены позже, после микрозадач.
     Примеры: setTimeout, setInterval, fetch, обработчики событий, requestAnimationFrame.

Как работает Event Loop:

1. Синхронный код выполняется сразу, пока стек вызовов не пуст. Event Loop ждет, пока стек опустеет.

2. Асинхронные операции:

   - Требующие внешней среды (`setTimeout`, `setInterval`, `fetch`, обработчики событий, `requestAnimationFrame`) инициируются через Web API/Node API. После того, как внешняя среда завершает операцию, их колбэки помещаются в очередь макрозадач.

   - Не требующие внешней среды (`Promise.then`, `catch`, `finally`, `queueMicrotask`, `MutationObserver`) инициируются внутри JS-движка и помещаются в очередь микрозадач.

3. Когда стек пуст:

   - Event Loop выполняет все микрозадачи из очереди, помещая их по очереди в стек.

   - Затем берётся одна макрозадача, её колбэк помещается в стек и выполняется.

   - Если во время макрозадачи создаются новые микрозадачи, они выполняются сразу после завершения этой макрозадачи, перед следующей макрозадачей.

4. Цикл повторяется бесконечно: сначала все микрозадачи → затем одна макрозадача → снова все микрозадачи → следующая макрозадача → и так далее.

Разница между микрозадачами и макрозадачами:

| Характеристика        | Микрозадачи                                                                 | Макрозадачи                                                                       |
| --------------------- |-----------------------------------------------------------------------------| --------------------------------------------------------------------------------- |
| **Приоритет**         | Выполняются **раньше**, чем макрозадачи                                     | Выполняются **после** всех микрозадач                                             |
| **Очередь**           | Micro Task Queue                                                            | Macro Task Queue                                                                  |
| **Примеры**           | `Promise.then`, `catch`, `finally`, `queueMicrotask`, `process.nextTick`, `MutationObserver`    | `setTimeout`, `setInterval`, `fetch`, обработчики событий, `requestAnimationFrame` |
| **Когда выполняются** | Сразу после завершения текущего стека вызовов, перед следующей макрозадачей | После того, как завершены все микрозадачи текущего цикла                          |

💡 Важно помнить:

- Event Loop не является частью JS-движка (например, V8) — он реализуется средой выполнения (браузер или Node.js).

- Микрозадачи всегда выполняются раньше макрозадач.

## 67. Расскажите о queueMicrotask?

`queueMicrotask()` добавляет переданную функцию в очередь микрозадач.

## 68. Что такое callback-функция? Что такое Callback Hell?

`Callback-функция` — это функция, передаваемая в качестве аргумента другой функции и 
вызываемая по мере выполнения этой функции. 

Это позволяет выполнять асинхронные операции и обрабатывать их результаты, когда они становятся доступны.

```javascript
function fetchData(callback) {
    setTimeout(() => {
        const data = "Данные загружены";
        callback(data);
    }, 1000);
}

fetchData((result) => console.log(result)); // Выводит "Данные загружены" через 1 секунду);
```

`Callback Hell (или “ад обратных вызовов”)` — это ситуация, когда код содержит много вложенных callback-функций,
что делает его трудночитаемым и сложным для поддержки.

```javascript
fetchData(result1 => {
    console.log(result1);
    fetchData(result2 => {
        console.log(result2);
        fetchData(result3 => {
            console.log(result3);
            // и так далее...
        });
    });
});
```

Проблему “callback hell” решают с помощью промисов и async/await, которые делают код асинхронных операций более читаемым.

## 69. Что такое промисы (Promises)?

`Promise` - это объект, представляющий результат асинхронной операции. Он может находиться в одном из трёх состояний:
`ожидание (pending)`, `выполнено (fulfilled)`, `отклонено (rejected)`. Промисы позволяют удобнее работать с асинхронным кодом,
избегая вложенных колбэков.

## 70. Методы промисов?

- `Promise.all()`

    Выполняется, когда все промисы успешно завершены. Если хотя бы один промис отклонён, возвращается ошибка этого промиса.
    
    ```js
    const promise1 = Promise.resolve(3);
    const promise2 = Promise.resolve(42);
    const promise3 = Promise.resolve('hello');
    
    Promise.all([promise1, promise2, promise3])
    .then(values => console.log(values)) // [3, 42, 'hello']
    .catch(error => console.error(error));
    ```

- `Promise.any()`

    Возвращает результат первого успешно выполненного промиса, игнорируя отклонённые до него. Если все промисы отклонены, возвращается ошибка типа `AggregateError`.
    
    ```js
    const promise1 = Promise.reject(new Error('Error 1'));
  
    const promise2 = Promise.resolve(42);
  
    const promise3 = Promise.reject(new Error('Error 2'));
    
    Promise.any([promise1, promise2, promise3])
        .then(value => console.log(value)) // 42
        .catch(error => console.error(error));
    ```

- `Promise.race()`

    Возвращает результат первого завершившегося промиса, независимо от того, успешно он выполнен или отклонён.

    ```js
    const promise1 = new Promise(resolve => setTimeout(resolve, 100, 'First'));
  
    const promise2 = new Promise(resolve => setTimeout(resolve, 200, 'Second'));
    
    Promise.race([promise1, promise2])
        .then(value => console.log(value)) // 'First'
        .catch(error => console.error(error));
    ```

- `Promise.allSettled()`

    Выполняется, когда все промисы завершены, независимо от результата. Возвращает массив объектов с состоянием каждого промиса (`fulfilled` или `rejected`).
    
    ```js
    const promise1 = Promise.resolve(3);
  
    const promise2 = Promise.reject(new Error('Error occurred'));
  
    const promise3 = Promise.resolve('hello');
    
    Promise.allSettled([promise1, promise2, promise3])
        .then(results => console.log(results));
    // [
    //   { status: 'fulfilled', value: 3 },
    //   { status: 'rejected', reason: Error('Error occurred') },
    //   { status: 'fulfilled', value: 'hello' }
    // ]
    ```

- `Promise.resolve()`

    Создаёт промис, который сразу успешно завершён с указанным значением.
    
    ```js
    const happyDog = Promise.resolve('🐶');
    
    happyDog.then(dog => console.log(dog)); // 🐶
    ```

- `Promise.reject()`

    Создаёт промис, который сразу отклонён с указанной причиной.
    
    ```js
    const sadDog = Promise.reject('🐶');
    
    sadDog.catch(dog => console.log(dog)); // 🐶
    ```

## 71. Что такое async/await?

`async/await` - это синтаксический сахар для работы с промисами, который позволяет писать асинхронный код так, как
если бы он был синхронным. `async` помечает функцию как асинхронную, `await` заставляет ждать выполнения промиса.

## 72. Отличие функции-конструктора и класса?

| Характеристика        | Функция-конструктор                                                | Класс (ES6)                                                         |
| --------------------- | ------------------------------------------------------------------ | ------------------------------------------------------------------- |
| **Синтаксис**         | Старый, через `function`                                           | Новый, через `class`                                                |
| **Под капотом**       | Функция + методы через `prototype`                                 | Синтаксический сахар над функцией-конструктором                     |
| **Подъем (hoisting)** | Функции поднимаются (можно вызвать до объявления)                  | Классы **не поднимаются** (ReferenceError при вызове до объявления) |
| **Строгий режим**     | Не обязательно (зависит от файла/скрипта)                          | Всегда работает в **строгом режиме** (`"use strict"`)               |
| **Вызов без `new`**   | Можно вызвать без `new` (но `this` будет `undefined` или `window`) | Без `new` вызовет **TypeError**                                     |
| **Наследование**      | Через `prototype` и `Object.create`                                | Через `extends` и `super` (читабельнее)                             |

## 73. Что такое ООП?

`ООП (объектно-ориентированное программирование)` — это парадигма программирования, основанная на представлении программы в виде совокупности объектов, которые взаимодействуют между собой.

Основные принципы ООП:

- `Инкапсуляция` — сокрытие внутренней реализации объекта и предоставление доступа только через публичный интерфейс (методы и свойства).

- `Наследование` — возможность создавать новые классы на основе существующих, наследуя их свойства и методы.

- `Полиморфизм` — возможность вызывать одинаковые методы у разных объектов, при этом результат зависит от конкретного типа объекта.

- `Абстракция` — выделение только значимых характеристик объекта, игнорируя детали реализации.

ООП реализуется через прототипное наследование, а с введением синтаксиса class (ES6) стало проще писать код в «классическом» стиле, сохраняя при этом прототипную природу языка.

## 74. Какие паттерны знаешь? (порождающие, структурные, поведенческие)

1. `Порождающие паттерны` — отвечают за создание объектов:

   - `Singleton (Одиночка)` — гарантирует, что существует только один экземпляр объекта.

   - `Factory Method (Фабричный метод)` — создаёт объекты через общий интерфейс без указания конкретного класса.

   - `Abstract Factory (Абстрактная фабрика)` — создает семейства связанных объектов.

   - `Builder (Строитель)` — пошагово конструирует сложные объекты.

   - `Prototype (Прототип)` — создаёт объекты на основе существующего шаблона (прототипа).

2. `Структурные паттерны` — описывают, как классы и объекты образуют более крупные структуры:

   - `Adapter (Адаптер)` — преобразует интерфейс одного класса к другому.

   - `Decorator (Декоратор)` — динамически добавляет объекту новое поведение.

   - `Facade (Фасад)` — упрощает сложную систему, предоставляя единый интерфейс.

   - `Proxy (Заместитель)` — контролирует доступ к объекту, добавляя промежуточный слой.

   - `Composite (Компоновщик)` — объединяет объекты в древовидную структуру.

3. `Поведенческие паттерны` — определяют взаимодействие между объектами:

   - `Observer (Наблюдатель)` — один объект следит за изменениями другого.

   - `Strategy (Стратегия)` — позволяет менять алгоритм поведения во время выполнения.

   - `Command (Команда)` — инкапсулирует запрос как объект.

   - `Mediator (Посредник)` — управляет взаимодействием между множеством объектов.

   - `State (Состояние)` — изменяет поведение объекта при смене внутреннего состояния.

## 75. Как работают классы под капотом? Прототипы.

`class` — это синтаксический сахар над функциями-конструкторами и прототипами.

Методы класса записываются в prototype, а объекты имеют скрытую ссылку `[[Prototype]]` (`__proto__`).

Если свойство не найдено у объекта, JS ищет его в цепочке прототипов (prototype chain).

```javascript
class User {
  sayHi() {
    console.log('Hi');
  }
}

const user = new User();
user.sayHi();
```

Под капотом эквивалентно:

```javascript
function User() {}
User.prototype.sayHi = function() {
  console.log('Hi');
};

const user = new User();
user.sayHi();
```

Наследование реализуется через `Object.create()` или ключевое слово `extends`, которое устанавливает прототип родителя.

# Браузерный JavaScript

## 1. Что такое DOM и BOM?

`DOM (Document Object Model)` — это объектная модель HTML-документа, представленная в виде дерева, где каждый элемент страницы — это узел (объект), к которому можно получить доступ и изменить через JavaScript.

DOM позволяет:

- добавлять, изменять и удалять элементы,

- менять стили и атрибуты,

- реагировать на события.

Браузер создаёт DOM при загрузке страницы, и доступ к нему осуществляется через объект document. Когда дерево готово, генерируется событие DOMContentLoaded.

`BOM (Browser Object Model)` — это модель, предоставляющая интерфейсы для взаимодействия с браузером (а не с HTML-документом).

Она не стандартизирована, поэтому реализация может отличаться в разных браузерах.

Основные объекты BOM:

- `window` — глобальный объект браузера, представляющий текущее окно. Например: window.alert('Привет!').

- `document` — объект DOM, представляющий страницу.

- `navigator` — информация о браузере и системе (navigator.userAgent).

- `location` — работа с URL (location.href = 'https://example.com').

- `history` — управление историей (history.back() / history.forward()).

- `screen` — данные о экране (screen.width, screen.height).

## 2. Типы узлов DOM-дерева?

- `Element`: узлы элементов, такие как `<div>`, `<p>`, `<a>`.

- `Attribute`: узлы атрибутов, связанные с элементами.

- `Text`: текстовые узлы, содержащие текст внутри элементов.

- `Comment`: узлы комментариев.

- `Document`: корневой узел документа.

- `DocumentFragment`: фрагмент документа, который можно использовать для временного хранения элементов.

## 3. Что такое распространение события (Event Propagation)?

Когда какое-либо событие происходит в элементе DOM, оно на самом деле происходит не только в нем. Событие
«распространяется» от объекта window до вызвавшего его элемента (event.target). При этом событие последовательно
пронизывает всех предков целевого элемента.

Этот процесс называется Event Propagation (распространение события).

Event Propagation имеет три стадии

1. `Фаза погружения` — событие возникает в объекте window и опускается до цели события через всех ее предков.

2. `Целевая фаза` — это когда событие достигает целевого элемента.

3. `Фаза всплытия` — событие поднимается от event.target, последовательно проходит через всех его предков и достигает
   объекта window.

## 4. Разница между e.preventDefault() и e.stopPropagation(), .stopImmediatePropagation()? Как узнать об использовании метода e.preventDefault()?

| Метод                        | Что делает                                                                               | Всплытие          | Другие обработчики |
|:-----------------------------| :--------------------------------------------------------------------------------------- | :---------------- | :----------------- |
| `preventDefault()`           | Отменяет стандартное поведение элемента (например, переход по ссылке, отправку формы).   | ✅ Продолжается    | ✅ Выполняются      |
| `stopPropagation()`          | Останавливает **всплытие** события (и погружение тоже).                                  | ❌ Останавливается | ✅ Выполняются      |
| `stopImmediatePropagation()` | Останавливает **всплытие** и **другие обработчики** этого же события на том же элементе. | ❌ Останавливается | ❌ Прерываются      |

- `composedPath()` возвращает массив элементов, по которым пройдёт событие. Обработчики на одном элементе вызываются в порядке их установки.

Чтобы определить, вызван ли метод `preventDefault`, можно проверить свойство `defaultPrevented` объекта события:

```javascript
handleEvent(e)
{
    if (e.defaultPrevented) {
        console.log('preventDefault был вызван');
    }
}
```

## 5. Что такое делегирование событий (Event Delegation)?

`Делегирование событий` — это подход, при котором обработчик ставится на родительский элемент, а не на каждый дочерний, а нужный элемент определяется через event.target.

Такой подход возможен благодаря всплытию событий.

## 6. Разница между event.target и event.currentTarget?

- `event.target`: элемент, на котором произошло событие.

- `event.currentTarget`: элемент, на который назначен обработчик события (может отличаться, если используется
  делегирование событий).

## 47. Типы всплывающих окон?

1. `alert()`:

    - Выводит сообщение с кнопкой "ОК".

    ```javascript
    alert("Это сообщение!");
    ```

2. `confirm()`:

    - Отображает сообщение с двумя кнопками: "ОК" и "Отмена". Возвращает `true`, если нажата "ОК", и `false`, если "Отмена".

    ```javascript
    let result = confirm("Вы уверены?");
   
    if (result) {
        console.log("Пользователь подтвердил.");
    } else {
        console.log("Пользователь отменил.");
    }
    ```

3. `prompt()`:

    - Позволяет пользователю ввести текст. Возвращает введенное значение или `null`, если пользователь нажал "Отмена".

    ```javascript
    let name = prompt("Введите ваше имя:");
   
    if (name !== null) {
        console.log("Привет, " + name + "!");
    }
    ```

## 7. Web Workers

`Web Worker` — это механизм в браузере, который позволяет запускать JavaScript в фоновом потоке, отдельно от основного потока (UI thread). Это помогает не блокировать интерфейс при выполнении тяжёлых вычислений.

[Дока](https://doka.guide/js/web-workers/)

## 8. Расскажите о IntersectionObserver?

`Intersection Observer` — браузерный API, который позволяет асинхронно отслеживать пересечение элемента с его родителем или областью видимости документа (viewport). 
В момент пересечения можно запустить какое-либо действие, например, подгрузить дополнительные посты в ленте новостей («бесконечный скролл») или сделать «ленивую» загрузку контента.

[Дока](https://doka.guide/js/intersection-observer/)

## 9. Разница между HTMLCollection и NodeList?

| Свойство                | HTMLCollection                                                           | NodeList                                                                                |
| ----------------------- | ------------------------------------------------------------------------ | --------------------------------------------------------------------------------------- |
| **Возвращаемые методы** | `getElementsByClassName()`, `getElementsByTagName()`                     | `querySelectorAll()`, `childNodes`                                                      |
| **Тип содержимого**     | Только элементы (`HTMLElement`)                                          | Любые узлы (`Element`, `Text`, `Comment`)                                               |
| **Живость**             | Всегда **живая** — обновляется при изменении DOM                         | Может быть **статической** (`querySelectorAll`) или **живой** (`childNodes`)            |
| **Итерация**            | Цикл `for` или `for...of` (не поддерживает `forEach` в старых браузерах) | Поддерживает `forEach` в современных браузерах; можно использовать `for` или `for...of` |
| **Применение**          | Когда нужны только элементы и живое обновление                           | Когда нужны любые узлы или статическая коллекция                                        |


## 10. Методы поиска элементов в DOM?

| Метод                               | Что ищет                            | Возвращаемое значение         |
| ----------------------------------- | ----------------------------------- | ----------------------------- |
| `getElementById(id)`                | Элемент по **id**                   | Один элемент (`HTMLElement`)  |
| `getElementsByClassName(className)` | Элементы по **классу**              | HTMLCollection (живой список) |
| `getElementsByTagName(tagName)`     | Элементы по **тегу**                | HTMLCollection (живой список) |
| `querySelector(selector)`           | Первый элемент по **CSS-селектору** | Один элемент (`Element`)      |
| `querySelectorAll(selector)`        | Все элементы по **CSS-селектору**   | NodeList (не живой список)    |

## 11. Как добавить обработчик события на DOM-элемент? Как удалить обработчик события с DOM-элемента?
   Добавить:

   ```javascript
   document.getElementById('myButton').addEventListener('click', function() {
     alert('Button clicked!');
   });
   ```
   Удалить:

   ```javascript
   function handleClick() {
     alert('Button clicked!');
   }

   const button = document.getElementById('myButton');
   button.addEventListener('click', handleClick);
   // Удаление обработчика
   button.removeEventListener('click', handleClick);
   ```

## 12. Сколько аргументов принимает addEventListener?

1. `type` (строка): Тип события, которое вы хотите слушать (например, `'click'`, `'mouseover'`, `'keydown'` и т.д.).
2. `listener` (функция): Функция, которая будет вызвана, когда событие произойдет. Это обработчик события.
3. `options` (объект или логическое значение, необязательный): Опции для настройки поведения события, такие как:
    - `capture`: Если `true`, обработчик будет вызван на этапе захвата события.
    - `once`: Если `true`, обработчик будет вызван только один раз после его добавления.
    - `passive`: Если `true`, это указывает браузеру, что обработчик не будет вызывать `preventDefault()`, что может улучшить производительность прокрутки.

## 13. Свойства для перемещения по DOM-дереву?

| Свойство                 | Что возвращает                      | Включает текстовые/комментарии?  |
| ------------------------ | ----------------------------------- | -------------------------------- |
| `parentNode`             | Родительский узел                   | ❌ (только узел)                  |
| `children`               | HTMLCollection дочерних элементов   | ❌ (только элементы)              |
| `firstElementChild`      | Первый дочерний элемент             | ❌                                |
| `lastElementChild`       | Последний дочерний элемент          | ❌                                |
| `previousElementSibling` | Предыдущий элемент на том же уровне | ❌                                |
| `nextElementSibling`     | Следующий элемент на том же уровне  | ❌                                |
| `childNodes`             | NodeList всех дочерних узлов        | ✅ (текст, комментарии, элементы) |
| `firstChild`             | Первый дочерний узел                | ✅                                |
| `lastChild`              | Последний дочерний узел             | ✅                                |

## 14. Разница между attribute и property у DOM-элементов?

- `Attribute`: относится к HTML-атрибутам, как они указаны в исходном коде. Например, `<input type="text" />`
  имеет атрибут `type`.

- `Property`: относится к свойствам объекта в DOM. Например, `element.type` указывает на текущее значение
  свойства `type`, которое может отличаться от значения атрибута.

## 15. Виды событий?

1. События взаимодействия с пользователем (UI Events):
   - `click` — нажатие на элемент.
   - `dblclick` — двойное нажатие на элемент.
   - `mousedown` — нажатие кнопки мыши.
   - `mouseup` — отпускание кнопки мыши.
   - `mousemove` — перемещение мыши.
   - `mouseenter` — перемещение указателя в область элемента.
   - `mouseleave` — уход указателя с элемента.
   - `mouseover` — наведение указателя на элемент.
   - `mouseout` — указатель покидает элемент.
   - `contextmenu` — вызов контекстного меню (обычно по правому клику мыши).
   - `input` — изменение значения в элементе ввода.

2. События клавиатуры (Keyboard Events):
   - `keydown` — нажатие клавиши.
   - `keyup` — отпускание клавиши.
   - `keypress` — нажатие клавиши (устарело, лучше использовать `keydown` и `keyup`).

3. События фокуса (Focus Events):
   - `focus` — получение фокуса элементом.
   - `blur` — потеря фокуса элементом.

4. События формы (Form Events):
   - `submit` — отправка формы.
   - `reset` — сброс формы.
   - `change` — изменение значения элемента формы.
   - `input` — ввод данных в элемент формы.

5. События загрузки (Load Events):
   - `load` — полная загрузка ресурса (страница, изображение).
   - `unload` — выгрузка ресурса.
   - `beforeunload` — событие перед выгрузкой ресурса.
   - `error` — ошибка при загрузке ресурса.

6. События мультимедиа (Media Events):
   - `play` — начало воспроизведения.
   - `pause` — пауза воспроизведения.
   - `ended` — завершение воспроизведения.
   - `volumechange` — изменение уровня громкости.

7. События касания (Touch Events):
   - `touchstart` — касание экрана.
   - `touchmove` — движение пальца по экрану.
   - `touchend` — завершение касания экрана.

8. События окна (Window Events):
   - `resize` — изменение размера окна.
   - `scroll` — прокрутка страницы.

9. Прочие события:
   - `DOMContentLoaded` — событие, когда HTML-документ был полностью загружен и обработан, не дожидаясь загрузки стилей, изображений и других ресурсов.
   - `hashchange` — изменение хэша в адресной строке.
   - `popstate` — изменение состояния истории (например, при навигации назад/вперед).
   - `storage` — изменение данных в `localStorage` или `sessionStorage`.

## 16. Разница между событиями load и DOMContentLoaded?

1. `DOMContentLoaded` срабатывает, когда браузер полностью загрузил и построил DOM-дерево, но до того, как загружены такие внешние ресурсы, как стили, изображения и другие элементы.

    - Событие полезно, когда нужно, чтобы HTML и JavaScript могли взаимодействовать сразу после загрузки DOM, без ожидания загрузки всех ресурсов.
    
    ```javascript
    document.addEventListener('DOMContentLoaded', () => {
      console.log('DOM полностью загружен и обработан');
      const element = document.querySelector('.my-element');
      // Можно безопасно взаимодействовать с DOM-элементами
    });
    ```
    В этом примере скрипт будет запущен, как только DOM-дерево будет построено, даже если изображения или стили еще не загружены.

2. `load` срабатывает, когда вся страница, включая все стили, изображения и другие внешние ресурсы, полностью загружена. Это полезно, если вам нужно выполнять действия, когда все ресурсы готовы к работе.

    ```javascript
    window.addEventListener('load', () => {
      console.log('Все ресурсы страницы загружены');
      const image = document.querySelector('.my-image');
      // Здесь вы можете быть уверены, что все изображения и стили загружены
    });
    ```
    В этом случае обработчик события сработает только после того, как все ресурсы, включая изображения и CSS, будут загружены.

## 17. Как динамически добавить элемент на HTML-страницу?

```javascript
const newElement = document.createElement('div');

newElement.textContent = 'Привет, мир!';

document.body.appendChild(newElement);
```

## 18. Разница между feature detection, feature inference и анализом строки user-agent?

| Подход                | Что делает                                                                | Пример                                        | Надёжность                                       |
| --------------------- | ------------------------------------------------------------------------- | --------------------------------------------- | ------------------------------------------------ |
| **Feature Detection** | Проверяет, поддерживает ли браузер конкретную функцию или API             | `if ('geolocation' in navigator)`             | Высокая — проверяется реальная поддержка         |
| **Feature Inference** | Делает вывод о возможностях браузера на основе версии или типа устройства | «Современный браузер → поддерживает CSS Grid» | Средняя — основано на предположениях             |
| **User-Agent**        | Извлекает информацию о браузере и устройстве из строки user-agent         | `'Chrome/58.0'` → понять браузер и версию     | Низкая — строку можно подделать, не всегда точна |

## 19. Разница между innerHTML и outerHTML?

`innerHTML` и `outerHTML` — это свойства объекта DOM, которые используются для работы с HTML-содержимым элементов. Вот основные различия между ними:

- `innerHTML`: возвращает или устанавливает HTML-содержимое внутри элемента. То есть, оно включает только содержимое между открывающим и закрывающим тегами элемента, исключая сами теги.

- `outerHTML`: возвращает или устанавливает HTML-содержимое элемента вместе с самим элементом. То есть, оно включает как содержимое, так и открывающий и закрывающий теги элемента.

Предположим, у нас есть следующий HTML-код:

```html
<div id="myDiv">
    <p>Привет, мир!</p>
</div>
```

Использование `innerHTML`

```javascript
const div = document.getElementById('myDiv');
console.log(div.innerHTML); // Вывод: <p>Привет, мир!</p>
div.innerHTML = '<p>Новое содержимое!</p>'; // Изменяет содержимое внутри div
```

После выполнения кода, содержимое `div` будет заменено на `<p>Новое содержимое!</p>`.

Использование `outerHTML`

```javascript
const div = document.getElementById('myDiv');
console.log(div.outerHTML); // Вывод: <div id="myDiv"><p>Привет, мир!</p></div>
div.outerHTML = '<div id="newDiv"><p>Новое содержимое!</p></div>'; // Заменяет весь div
```

После выполнения кода, весь элемент `div` будет заменен на `<div id="newDiv"><p>Новое содержимое!</p></div>`.

## 20. Для чего используется метод .focus()?

Метод `.focus()` используется для установки фокуса на элемент пользовательского интерфейса, например, на поле ввода, кнопку или любой другой интерактивный элемент.

Когда элемент получает фокус, он становится активным для ввода данных или взаимодействия, что обычно сопровождается выделением элемента.

Применение метода `.focus()`:

1. Можно автоматически установить фокус на поле ввода при загрузке страницы или после выполнения определенного действия, что улучшает пользовательский опыт.

   ```javascript
   document.getElementById('myInput').focus();
   ```

2. При работе с формами, можно устанавливать фокус на следующем элементе после завершения ввода данных.

3. Правильное использование метода `.focus()` может улучшить доступность приложения для пользователей, использующих клавиатуру.

4. При открытии модального окна можно установить фокус на первое поле ввода, чтобы пользователь мог сразу начать ввод данных.

```html
<input type="text" id="username" placeholder="Введите ваше имя">
<button onclick="setFocus()">Установить фокус на поле ввода</button>

<script>
function setFocus() {
    document.getElementById('username').focus();
}
</script>
```
В этом примере при нажатии кнопки фокус будет установлен на поле ввода с id "username".

## 21. Для чего используется свойство .forms?

Свойство `.forms` объекта `document` возвращает коллекцию всех форм в документе (HTMLCollection).

## 22. Для чего используется метод .scrollIntoView()?

Метод `.scrollIntoView()` прокручивает элемент так, чтобы он оказался видимым в области просмотра. Это может быть
полезно для приведения элемента в фокус.

## 23. Разница между методами .submit() и .requestSubmit()?

- `.submit()`: отправляет форму, обходя валидацию HTML5 и обработчики события `submit`.

- `.requestSubmit()`: отправляет форму, включая валидацию HTML5 и вызов обработчиков события `submit`.

## 24. Расскажите о URLSearchParams?

`URLSearchParams` — это класс, предоставляющий удобное API для формирования строки поисковых параметров, которую потом можно использовать для формирования полного адреса. 
Все параметры в строке будут закодированы для безопасной вставки в адрес. 
Также этот класс можно встретить как часть класса URL.

```javascript
let params = new URLSearchParams('?name=John&age=30');
console.log(params.get('name')); // John
console.log(params.has('age'));  // true
params.append('city', 'New York');
console.log(params.toString()); // name=John&age=30&city=New+York
```

[Дока](https://doka.guide/js/urlsearchparams/)

## 26. Как можно создавать пользовательское событие (custom events)?

Событие может быть создано с помощью кода. 
Поле isTrusted в таком событии будет содержать значение false, а, значит, мы будем знать, что событие было вызвано не системно и не пользователем.

Своё событие и вызовем его на window:

```javascript
const myEvent = new CustomEvent('my-event', {
  detail: {
    spicy: 123,
  },
})

window.addEventListener('my-event', function(evt) {
  console.log('В поле spicy:', evt.detail.spicy)
})

window.dispatchEvent(myEvent)
```

## 12. Типы таймеров?

- `setTimeout` выполняет функцию через определённое время.
- `setInterval` выполняет функцию с заданным интервалом.
- `requestAnimationFrame` выполняет функцию перед следующим перерисовкой экрана.

## 27. Расскажите о методе requestAnimationFrame()?

- Планирует вызов функции перед следующей перерисовкой браузера.

- Используется для анимаций, чтобы они были плавными и синхронизированы с кадровой частотой дисплея.

Особенности:

- Вызывается один раз или рекурсивно для повторяющейся анимации.

- Позволяет браузеру оптимизировать перерисовку и экономить ресурсы (в отличие от setTimeout или setInterval).

- Передает timestamp функции — время текущего кадра.

```javascript
function animate(time) {
  // Логика анимации, например, движение объекта
  box.style.left = (time / 10) + 'px';

  // Запрашиваем следующий кадр
  requestAnimationFrame(animate);
}

requestAnimationFrame(animate);
```

[LearnJS](https://learn.javascript.ru/js-animation)

## 28. Для чего используется свойство .dataset?

Свойство `dataset` позволяет считывать или устанавливать любые дата-атрибуты на HTML-элементе.

`Дата-атрибут `— это пользовательский атрибут на элементе, название которого начинается с data-, например data-testid. Дата атрибуты используются, чтобы хранить значения на элементах в HTML.

```javascript
<div id="item" data-id="123" data-role="admin"></div>

const div = document.getElementById('item');

// Чтение
console.log(div.dataset.id);    // "123"
console.log(div.dataset.role);  // "admin"

// Изменение
div.dataset.role = 'user';
console.log(div.dataset.role);  // "user"

// Добавление нового атрибута
div.dataset.status = 'active';
console.log(div.dataset.status); // "active"
```

[Дока](https://doka.guide/js/element-dataset/)