# React

## 1. Что такое React?

`React` — библиотека для создания пользовательских интерфейсов, разработана Facebook в 2011 году. 

Основная идея — разбиение UI на компоненты и управление их состоянием.

Ключевые особенности:

- Компоненты — интерфейс строится из переиспользуемых компонентов.

- Однонаправленный поток данных — данные идут сверху вниз через props.

- React Fiber — новый механизм рендеринга, поддерживающий асинхронные обновления.

- JSX — синтаксис для описания UI в виде HTML-подобного кода внутри JS.

- Hooks — использование состояния и эффектов в функциональных компонентах.

- Декларативный UI — разработчик описывает что должно быть отображено в зависимости от определенного
  состояния, а не пошаговые изменения.

- Экосистема — множество библиотек (React Router, Redux и др.) и большое сообщество.

## 2. Техники оптимизации перфоманса React?

1. Мемоизация компонентов

   - React.memo(Component) — предотвращает перерисовку компонента, если props не изменились.

   - Используется для функциональных компонентов.

2. Мемоизация функций и значений

   - useCallback — мемоизирует функции, чтобы не создавать новые при каждой перерисовке.

   - useMemo — мемоизирует вычисленные значения, чтобы не пересчитывать их лишний раз.

3. Оптимизация списка и рендеринга

   - key у элементов списка для правильного обновления.

   - Виртуализация списков (react-window, react-virtualized) для длинных списков.

4. Разделение кода (Code Splitting)

   - React.lazy + Suspense — подгружает компоненты по требованию, уменьшает размер начального бандла.

5. Избегание лишних перерисовок

   - Поднять state выше (lifting state up) только там, где нужно.

   - Делать локальные state для часто обновляемых компонентов.

6. Оптимизация контекста

   - Контекст вызывает перерисовку всех подписанных компонентов — мемоизация и разбивка на несколько контекстов помогает.

7. Профилирование

   - Использовать React.Profiler или DevTools, чтобы выявлять медленные компоненты.

## 3. Лучшие практики безопасности?

Избегать XSS, не хранить секреты на клиенте, валидировать данные на сервере, использовать CSRF-токены и современные заголовки безопасности.

## 4. Что такое React Fiber? Как проходит согласование изменений DOM в React?

[Объяснение - React (продвинутый)](https://www.youtube.com/watch?v=HDajDASxn-w)

`React Fiber` — это механизм рендеринга, появившийся в версии 16.
Он был создан для того, чтобы сделать процесс обновления интерфейса асинхронным, управляемым и приоритетным, сохраняя концепцию Virtual DOM.

До появления Fiber React просто делал синхронный diff между старым и новым виртуальным DOM и сразу применял изменения в реальный DOM.

**Две фазы работы React Fiber**

1. `Render (Reconciliation)` — React строит новое дерево Fiber (`Work-in-Progress`) на основе предыдущего (`Current`).

2. `Commit` — React применяет подготовленные изменения к реальному DOM и вызывает эффекты.

**Принцип работы React Fiber:**

**Фаза 1. Render (Reconciliation)**

При первом рендере создаётся дерево React-элементов.

Для каждого элемента создаётся Fiber Node — объект, который хранит информацию о компоненте, его состоянии, типе, пропсах и связях с другими элементами.

Каждый Fiber Node имеет ссылки:

- `child` — дочерний Fiber

- `sibling` — соседний Fiber

- `return` — родительский Fiber

- `alternate` — ссылка на соответствующую ноду из предыдущего дерева (Current Tree).

Все связи начинаются с Host Root — корневого Fiber Node.

Таким образом, дерево Fiber представляет собой связанный список (Linked List), а не классическое дерево.

![fiber](./../assets/react/fiber-node.png)

![fiber](./../assets/react/fiber.png)

![Host Root](./../assets/react/host-root-hode.png)

**Создание и обновление Fiber**

- При маунте создаётся новое дерево Fiber.

- При обновлении создаётся новое дерево `Work-in-Progress Tree`, где каждая нода имеет ссылку (`alternate`) на соответствующую ноду из предыдущего дерева (`Current Tree`).

- После завершения обновления `Work-in-Progress Tree` становится новым `Current Tree`.

- При удалении элемента его Fiber Node уничтожается.

**Ход работы во время Render-фазы**

React проходит дерево Fiber, начиная с Host Root, спускаясь вниз к самым глубоким дочерним элементам.
Если у элемента есть работа (изменения), React выполняет её.
Если нет — поднимается обратно и продолжает обход соседних узлов.
Когда все ноды обработаны, React собирает список эффектов и готовит их к выполнению на следующей фазе.

**Особенности Render-фазы**

Она может быть может быть прервана или приостановлена для поддержания отзывчивости интерфейса (Concurrent Mode), если есть задачи более высокого приоритета, и возобновлена позже для продолжения работы.

Приоритет задач задаётся планировщиком (Scheduler):

- `Высокий приоритет` — действия пользователя и визуальные изменения (useLayoutEffect)

- `Средний приоритет` — обновления состояния и перерендеры (useEffect)

- `Низкий приоритет` — фоновые или отложенные задачи (например, предзагрузка данных)

Ранние версии Fiber использовали `requestIdleCallback` для распределения задач в свободное время браузера,
но современные версии React используют встроенный планировщик (Scheduler), который обеспечивает более точный и кроссбраузерный контроль выполнения задач.

**Эвристики сравнения (Reconciliation)**

- Элементы разных типов создают новые деревья. Под элементами разных типов подразумеваются по факту элемены с разными именами: `<span>` → `<div>` или `Component1` → `Component2`.

- Использование ключей (key) помогает React отслеживать неизменившиеся элементы между рендерами и эффективно переиспользовать их Fiber Node.

**Фаза 2. Commit**

Эта фаза синхронная и не может быть прервана.
React применяет все накопленные изменения и эффекты к реальному DOM.

Порядок действий:

1. Применяются изменения в DOM.

2. Выполняются эффекты с высоким приоритетом (`useLayoutEffect`, `componentDidMount`, `componentDidUpdate`).

3. Затем запускаются обычные эффекты (`useEffect`) и подписки.

После этого новое дерево Fiber (`Work-in-Progress Tree`) становится текущим (`Current Tree`), и цикл работы React завершается.

## 4. Что такое конкурентный режим? Как его включить? Для чего конкурентный режим был введен на уровне архитектуры React? Какие “фичи“ предоставляет конкурентный режим?

`Concurrent Mode` — это режим работы React, который позволяет асинхронно и приоритетно обрабатывать рендеринг, делая интерфейс более отзывчивым.

В обычном (синхронном) режиме каждый ререндер блокирует главный поток, а в Concurrent Mode React может:

- Приостанавливать Render-фазу, если есть более приоритетные задачи (например, действия пользователя).

- Возобновлять рендеринг позже, чтобы интерфейс не «замораживался».

- Разбивать рендеринг на небольшие части, обрабатывая их постепенно.

Преимущества:

- Плавные интерфейсы даже при больших обновлениях.

- Предотвращение "заморозки" UI при тяжёлых вычислениях.

- Улучшенная отзывчивость для анимаций и пользовательских событий.

Как включить Concurrent Mode

На текущий момент в React 18+ используется Concurrent Features через `createRoot` вместо устаревшего `ReactDOM.render`:

```javascript
import { createRoot } from 'react-dom/client';
import App from './App';

const container = document.getElementById('root');
const root = createRoot(container); // создаём concurrent root
root.render(<App />);
```

Для отдельных компонентов можно использовать транзишны (`startTransition`), чтобы пометить обновления как низкоприоритетные:

```javascript
import { startTransition } from 'react';

startTransition(() => {
setState(newValue); // низкоприоритетное обновление
});
```

## 5. Хуки

`Хуки` – это функции, которые позволяют работать с состоянием, жизненным циклом и другими возможностями React в функциональных компонентах.

1. `useState`

   Используется для управления состоянием в функциональном компоненте.
    
    ```javascript
    const [value, setValue] = useState(defaultValue);
    ```
    - value — текущее значение состояния
    - setValue — функция для его изменения, вызывает ререндер. При вызове setValue React ожидает новое значение, а не мутированное старое.
      Если передать ту же ссылку (например, мутировать объект), React не заметит изменений и не выполнит повторный рендер.

    Если новое состояние зависит от предыдущего, можно передать колбек:
    
    ```javascript
    setValue(prev => prev + 1);
    ```

    ```javascript
    import React, {useState} from 'react';
    
    function Counter() {
        const [count, setCount] = useState(0);
    
        return (
            <div>
                <p>Счетчик: {count}</p>
                <button onClick={() => setCount(count + 1)}>Увеличить</button>
            </div>
        );
    }
    ```

---

2. `useEffect`

   Позволяет выполнять побочные эффекты: запросы, таймеры, подписки и т.д. Принимает функцию и массив зависимостей:

    ```javascript
    useEffect(() => {
      // эффект
      return () => { /* очистка при размонтировании (аналог componentWillUnmount) */ }; 
    }, [deps]);
    ```

    - `без зависимостей` → вызывается на каждый рендер (монтирование и обновление)
    
    - `[]` → вызывается один раз при монтировании (аналог componentDidMount)
    
    - `[deps]` → вызывается при при монтировании + каждый раз при изменении deps (аналог componentDidUpdate для конкретных данных)

    ```javascript
    import React, {useEffect, useState} from 'react';
    
    function Timer() {
    const [time, setTime] = useState(0);
    
        useEffect(() => {
            const timer = setInterval(() => {
                setTime(prev => prev + 1);
            }, 1000);
    
            return () => clearInterval(timer);
        }, []);
    
        return <div>Время: {time} секунд</div>;
    }
    ```

---

3. `useLayoutEffect`

   Аналог useEffect, но выполняется синхронно до отрисовки DOM (аналог getSnapshotBeforeUpdate). Нужен, когда эффект влияет на DOM (например, измерения, позиционирование).

    ```javascript
    import React, {useLayoutEffect, useRef} from 'react';
    
    function LayoutExample() {
        const divRef = useRef();
    
        useLayoutEffect(() => {
            divRef.current.style.color = 'red';
        }, []);
    
        return <div ref={divRef}>Этот текст станет красным</div>;
    }
    ```

---

4. `useContext`

    Используется для передачи данных через дерево компонентов, минуя промежуточные компоненты.

    ```javascript
    import React, {createContext, useContext} from 'react';
    
    // Создание контекста
    const LanguageContext = React.createContext('en');
    
    // Компонент Provider
    const LanguageProvider = ({children}) => {
    const [language, setLanguage] = React.useState('en');
    
        return (
            <LanguageContext.Provider value={{language, setLanguage}}>
                {children}
            </LanguageContext.Provider>
        );
    };
    
    // Компонент Consumer
    const Greeting = () => {
    const {language} = React.useContext(LanguageContext);
    
        return <h1>{language === 'en' ? 'Hello!' : '¡Hola!'}</h1>;
    };
    
    // Использование
    const App = () => (
    <LanguageProvider>
        <Greeting/>
    </LanguageProvider>
    );
    ```

    Основные элементы:
    
    - `createContext` — создание контекста

   - `Provider` — предоставляет значение

   - `useContext` — позволяет получить это значение внутри компонента

   - `Consumer` — позволяет компонентам получать данные из контекста
    
    ```jsx
    // Создание контекста
    const LanguageContext = React.createContext('en');
    
    // Компонент Provider
    const LanguageProvider = ({children}) => {
        const [language, setLanguage] = React.useState('en');
    
        return (
            <LanguageContext.Provider value={{language, setLanguage}}>
                {children}
            </LanguageContext.Provider>
        );
    };
    
    // Компонент Consumer
    const Greeting = () => {
        const {language} = React.useContext(LanguageContext);
    
        return <h1>{language === 'en' ? 'Hello!' : '¡Hola!'}</h1>;
    };
    
    // Использование
    const App = () => (
        <LanguageProvider>
            <Greeting/>
        </LanguageProvider>
    );
    ```
    
    ⚠️ Важно: при изменении значения контекста перерисовываются все компоненты, использующие useContext.

---

5. `useReducer`

    Предназначен для управления состоянием, при сложной логике изменения состояния или когда текущее состояние зависит от предыдущего. 
    
    Он принимает редуктор (reducer), который обновляет состояние на основе действия (action): типа (type) и,
    опционально, полезной нагрузки (payload).
    
    ```javascript
    import React, {useReducer} from 'react';
    
    const initialState = {count: 0};
    
    function reducer(state, action) {
        switch (action.type) {
            case 'increment':
                return {count: state.count + 1};
            case 'decrement':
                return {count: state.count - 1};
            default:
                throw new Error();
        }
    }
    
    function Counter() {
        const [state, dispatch] = useReducer(reducer, initialState);
    
        return (
            <>
                Count: {state.count}
                <button onClick={() => dispatch({type: 'increment'})}>+</button>
                <button onClick={() => dispatch({type: 'decrement'})}>-</button>
            </>
        );
    }
    ```

---

6. `useCallback`

    Возвращает мемоизированную функцию, которая пересоздаётся только при изменении зависимостей.

    Полезен, когда передаётся функция как пропсы в дочерние компоненты и нужно избежать их пересоздания, что может привести к ненужным рендерам дочерних компонентов.
    
    ```javascript
    import React, {useCallback, useState} from 'react';

    function Button({onClick}) {
        console.log('Кнопка перерисована');
        return <button onClick={onClick}>Нажми меня</button>;
    }
    
    function App() {
        const [count, setCount] = useState(0);
    
        const handleClick = useCallback(() => {
            setCount(prev => prev + 1);
        }, []);
    
        return (
            <>
                <Button onClick={handleClick}/>
                <p>Счетчик: {count}</p>
            </>
        );
    }
    ```

---

7. `useMemo`

    Мемоизирует результат вычислений, чтобы не пересчитывать их при каждом рендере.

    Полезен, когда есть дорогостоящие вычисления, которые не нужно пересчитывать, если
    зависимости не изменились.
    
    ```javascript
    import React, {useMemo, useState} from 'react';
    
    function App() {
        const [count, setCount] = useState(0);
    
        const expensiveValue = useMemo(() => {
            return count * 2; // допустим, это тяжёлая операция
        }, [count]);
    
        return (
            <>
                <p>Счетчик: {count}</p>
                <p>Значение: {expensiveValue}</p>
                <button onClick={() => setCount(count + 1)}>+</button>
            </>
        );
    }
    ```

---

8. `useRef`

    Хранит мутируемое значение, которое не вызывает ререндер при изменении.
    Используется для доступа к DOM-элементам или сохранения любого значения между рендерами (как this.something в классовом).
    
    ```javascript
    import React, {useRef} from 'react';
    
    function FocusInput() {
        const inputRef = useRef();
    
        const focusInput = () => {
            inputRef.current.focus();
        };
    
        return (
            <>
                <input ref={inputRef} type="text"/>
                <button onClick={focusInput}>Фокус</button>
            </>
        );
    }
    ```

    Важно:

    - `ref.current` можно менять без ререндера

    - в `ref` можно хранить не только DOM-элемент, но и любое значение

    - для проброса `ref` в дочерний компонент используют `forwardRef`

    ```jsx
    import React, {forwardRef} from 'react';
    
    // Компонент Input, который принимает ref
    const Input = forwardRef((props, ref) => {
    return <input ref={ref} {...props} />;
    });
    
    export default Input;
    ```

    Ситуации, в которых использование рефов является оправданным:

    - Управление фокусом
    - Выделение текста
    - Вызов scrollTo
    - Вызов анимаций
    - Интеграция со сторонними DOM-библиотеками

---

9. `useTransition`  Где использвать? Можно ли оборачивать в него любые side-effects?

Позволяет пометить обновление состояния как низкоприоритетное, чтобы UI оставался отзывчивым при срочных действиях пользователя.

Где использовать:

- При больших обновлениях интерфейса (например, фильтрация или сортировка больших списков).

- Когда есть операции, которые можно выполнить позже, без блокировки срочных действий (клики, анимации).

Важно: нельзя оборачивать в `useTransition` любые side-effects.

- Side-effects должны оставаться в `useEffect`/`useLayoutEffect`.

- `useTransition` только управляет обновлением состояния, которое приводит к ререндеру.

```javascript
const [isPending, startTransition] = useTransition();

startTransition(() => setFilteredItems(largeArray.filter(...)));
```

---

10. `useDeferredValue` Где использовать? Можно ли сказать, что debounce функции больше не нужны?

Откладывает применение значения состояния до тех пор, пока нет задач более высокого приоритета.

Где использовать:

- Для больших списков, когда значение изменяется часто (например, ввод в поисковую строку).

- Обеспечивает плавное отображение без «заморозки» интерфейса.

Важно:

- `useDeferredValue` не заменяет полностью debounce.

- Он управляет приоритетом ререндеринга, а `debounce` уменьшает количество вызовов функции (например, API-запросов).

```javascript
const deferredSearch = useDeferredValue(searchInput);

const filteredItems = items.filter(item => item.includes(deferredSearch));
```

---

11. Правила создания пользовательского хука:

   - Название хука должно начинаться с use.
   - Следует использовать сначала встроенные хуки, если они решают нужную задачу, прежде чем создавать свои.
   - Нельзя вызывать хук условно. Хук надо вызывать тогда, когда это необходимо.
   - В хуке должна быть только логика, которую можно использовать повторно. Не стоит добавлять в него код, который нужен
     только в одном месте.
   - Хук должен быть чистой функцией.
   - Хук может возвращать значение или вызывать другие хуки. Это позволяет создавать цепочки обработки данных.
   - Название хука должно быть понятным и отражать его назначение. Это поможет другим разработчикам понять, что делает этот
     хук и как его можно использовать.

## 6. React.memo? Если изменились props родительского компонента, от которых не зависят дочерние, то случится ли ререндер дочерних элементов? Как избежать их ререндера?

В React по умолчанию при ререндере родительского компонента все дочерние компоненты тоже ререндерятся, даже если их props не изменились.

`React.memo` - это компонент высшего порядка (HOC), который предотвращает повторный рендеринг компонента, если его пропсы не изменились, в функциональных компонентах.

```jsx
const MyComponent = React.memo((props) => {
// компонент рендерится только если props изменяются
    return <div>{props.value}</div>;
});
```

## 7. Что Такое JSX?

`JSX (JavaScript XML)` — это синтаксический сахар для описания структуры UI в JavaScript, который позволяет писать
HTML-подобный код внутри JavaScript-файлов.

## 8. Что такое фрагмент (Fragment)?

`Фрагмент (Fragment)` — это специальный элемент, позволяющий возвращать группу элементов без
помещения их в дополнительный DOM узел.

## 9. Разница между элементом, компонентом и контейнером?

- `Элемент`: Основной строительный блок React, описывающий, что отображается на экране. React-элементы иммутабельны.

- `Компонент`: Функция или класс, возвращающий элемент или элементы для отображения. Может быть как чисто визуальным,
так и содержать логику.

- `Контейнер`: Компонент, который управляет состоянием и передачей данных другим компонентам.

## 10. Для чего нужен атрибут key при рендере списков?

`Атрибут key` используется для идентификации элементов в списке. Это помогает React более эффективно обновлять и
перерисовывать только измененные элементы списка, минимизируя затраты на рендеринг.

## 11. Что такое Компонент высшего порядка (Higher-Order Component/HOC)?

`Компонент высшего порядка (Higher-Order Component, HOC)` — это паттерн, который позволяет повторно использовать
логику между разными компонентами. HOC представляет собой функцию, которая принимает компонент и возвращает новый
компонент с добавленной функциональностью.

```jsx
// Функция HOC
const withLogging = (WrappedComponent) => {
    return (props) => {
        console.log('Props:', props);
        return <WrappedComponent {...props} />;
    };
};

// Компонент, который мы оборачиваем
const MyComponent = ({message}) => {
    return <div>{message}</div>;
};

// Использование HOC для оборачивания компонента
const MyComponentWithLogging = withLogging(MyComponent);

// В рендере
<MyComponentWithLogging message="Hello, HOC!"/>
```

## 12. Разница между управляемыми (controlled) и не управляемыми (uncontrolled) компонентами?

`Управляемые компоненты:`

Это компоненты, у которых отображение зависит от состояния, и состояние зависит от того, что отображается.
React полностью управляет значением элемента — оно хранится в state, а изменения происходят через setState.

```jsx
function ControlledInput() {
    const [inputValue, setInputValue] = useState('');

    const handleChange = (e) => {
        setInputValue(e.target.value);
    };

    return (
        <input
            type="text"
            value={inputValue}
            onChange={handleChange}
        />
    );
}
```

`Неуправляемые компоненты:`

У таких компонентов состояние хранится внутри самого DOM-элемента, и React не отслеживает его напрямую.
Чтобы получить значение, используется ref.

```jsx
function UncontrolledInput() {
    const inputRef = useRef();
    
    const handleSubmit = () => console.log(inputRef.current.value);
    
    return <>
        <input ref={inputRef} />
        <button onClick={handleSubmit}>Submit</button>
    </>;
}
```

## 13. Как реализовать двустороннее связывание данных?

`Двустороннее связывание данных (two-way data binding)` можно реализуется с помощью контролируемых компонентов.
Это процесс, когда изменения в интерфейсе пользователя (например, в форме) обновляют состояние компонента, и, наоборот,
изменения в состоянии компонента обновляют интерфейс.

## 14. Жизненный цикл компонента (классовые компоненты)

`Жизненный цикл компонента` — это последовательность этапов, через которые проходит компонент от его создания до удаления из DOM. Каждый этап связан с определёнными методами, которые позволяют управлять поведением компонента.

1. Монтирование (Mounting)

    Компонент создаётся и добавляется в DOM.

    - `constructor(props)` — вызывается перед монтированием компонента. Используется для инициализации состояния и привязки методов.

    - `static getDerivedStateFromProps(props, state)` — вызывается перед каждым рендером, включая первый (монтирование). Позволяет синхронизировать состояние с `props`.

    - `render()` — единственный обязательный метод. Возвращает JSX, который описывает UI компонента.

    - `componentDidMount()` — вызывается сразу после монтирования компонента. Используется для побочных эффектов (например, запросы к API, подписки).

2. Обновление (Updating)

    Происходит при изменении состояния компонента.

    - `static getDerivedStateFromProps(props, state)` — вызывается перед каждым рендером при обновлении.

    - `shouldComponentUpdate(nextProps, nextState)` — позволяет оптимизировать производительность, позволяя контролировать, нужно ли перерисовывать компонент (возвращает true или false).

    - `render()` — перерисовывает компонент на основе новых данных.

    - `getSnapshotBeforeUpdate(prevProps, prevState)` — вызывается прямо перед обновлением DOM. Позволяет компоненту получить информацию из DOM перед возможным обновлением (например, позиция прокрутки). Возвращает в качестве значения какой-то отдельный аспект, который передается в качестве третьего параметра в метод `componentDidUpdate()` и может учитываться в `componentDidUpdate` при обновлении. Если нечего возвращать, то возвращается значение `null`.

    - `componentDidUpdate(prevProps, prevState, snapshot)` — вызывается после обновления компонента. Здесь удобно реагировать на изменения и выполнять дополнительные действия. В качестве параметров передаются старые значения объектов `props` и `state`. Третий параметр - значение, которое возвращает метод `getSnapshotBeforeUpdate`.

3. Размонтирование (Unmounting)

   Компонент удаляется из DOM.

    - `componentWillUnmount()` — вызывается перед размонтированием компонента. Используется для очистки ресурсов (таймеров, подписок и т.д.).

4. Обработка ошибок (Error handling)

   Эти методы позволяют перехватывать и обрабатывать ошибки в процессе рендеринга дочерних компонентов.

   - `static getDerivedStateFromError(error)` — вызывается при возникновении ошибки в компоненте. Позволяет обновить состояние на основе ошибки (например, для отображения fallback UI).

   - `componentDidCatch(error, info)` — используется для обработки ошибок, возникших в процессе рендеринга дочерних компонентов. Используется для логирования и отображения запасного интерфейса.

Источник - https://metanit.com/web/react/2.6.php.

## 15. Что такое предохранители (Error Boundaries)?

`Error Boundaries (Предохранители)` — это классовые компоненты, которые отлавливают ошибки в дочерних компонентах и отображают запасной UI вместо падения всего приложения.

Ключевые моменты:

- Работают только в классовых компонентах (хуков для этого нет).

- Ловят ошибки в методе рендера, в методах жизненного цикла и в конструкторах дочерних компонентов.

- Не ловят ошибки в:

    - обработчиках событий,

    - асинхронном коде (setTimeout, промисы),

    - серверном рендеринге,

    - самом предохранителе.

Основные методы:

- static getDerivedStateFromError(error) — обновляет состояние для отображения запасного UI.

- componentDidCatch(error, info) — позволяет логировать ошибку.

⚠️ Важно: У этих методов нет аналога в функциональных компонентах, используются только классовые Error Boundaries.

Количество предохранителей:

Строгого ограничения на количество ErrorBoundary нет.
Можно использовать их сколько угодно — хоть один на всё приложение, хоть по одному на каждый компонент.

```javascript
class ErrorBoundary extends React.Component {
  constructor(props) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError() {
    return { hasError: true };
  }

  componentDidCatch(error, info) {
    console.error("Error caught by Error Boundary:", error, info);
  }

  render() {
    if (this.state.hasError) {
      return <h1>Что-то пошло не так.</h1>;
    }
    return this.props.children;
  }
}

// Использование
function App() {
  return (
    <ErrorBoundary>
      <MyComponent />
    </ErrorBoundary>
  );
}
```

Другие способы обработки ошибок:

| Тип ошибки                         | Как обрабатывается                              | Где используется |
| ---------------------------------- | ----------------------------------------------- | ---------------- |
| Ошибка в рендере компонента        | `Error Boundary`                                | В дереве React   |
| Ошибка в обработчике событий       | `try/catch` внутри функции                      | Вручную          |
| Ошибка в async/await или Promise   | `try/catch` или `.catch()`                      | Асинхронный код  |
| Глобальная ошибка (всё приложение) | `window.onerror`, `window.onunhandledrejection` | Вне React        |

`Error Boundaries` — это единственный встроенный React-механизм, предназначенный специально для отлова ошибок рендера компонентов.
Всё остальное (события, async/await, глобальные ошибки) нужно обрабатывать вручную с помощью try/catch или нативных API браузера.

## 16. Что такое PureComponent?

`React.PureComponent` — это классовый компонент, который автоматически реализует метод `shouldComponentUpdate` с поверхностным сравнением `props` и `state`. Если значения не изменились, повторный рендер не выполняется.

Основные моменты:

- Поверхностное сравнение — сравниваются только верхние уровни объектов. Для вложенных структур (`{a: {b: 1}}`) изменения могут не определиться → возможны баги.

- Оптимизация — уменьшает количество ненужных ререндеров.

- Использование — вместо `Component` можно наследоваться от `PureComponent`.

```javascript
import React, { PureComponent } from "react";

class MyComponent extends PureComponent {
  render() {
    return <div>{this.props.value}</div>;
  }
}
```

⚠️ Важно:

- Для функциональных компонентов аналог — React.memo.

- Если props или state — сложные объекты, изменения внутри них могут не отразиться (нужна иммутабельность).

## 17. Что такое портал (Portal)?

`Портал (Portal)` — это способ рендеринга дочерних компонентов в DOM-узле, который находится вне иерархии
родительского компонента. Это полезно в случаях, когда нужно отобразить компонент, например, модальное окно или
всплывающее меню, над другими компонентами, не нарушая их структуру.

Основные особенности порталов:

1. `Отдельный DOM-узел`: Компонент, использующий портал, будет отрисован в указанном узле, но всё еще будет частью
   иерархии компонентов. Это значит, что он может продолжать получать контекст и события от родительских
   компонентов.

2. `Создание портала`: Для создания портала используется метод `ReactDOM.createPortal()`, который принимает
   два аргумента:
    - `children`: дочерние компоненты, которые вы хотите отобразить.
    - `container`: DOM-узел, в который будут отрисованы дочерние компоненты.

```jsx
import React from 'react';
import ReactDOM from 'react-dom';

const Modal = ({children}) => {
    return ReactDOM.createPortal(
        <div className="modal">
            {children}
        </div>,
        document.getElementById('modal-root')
    );
};

const App = () => {
    return (
        <div>
            <h1>Приложение</h1>
            <Modal>
                <h2>Это модальное окно!</h2>
            </Modal>
        </div>
    );
};

export default App;
```

`Когда использовать порталы:`

- Для создания модальных окон, всплывающих уведомлений, тултипов и других компонентов, которые должны визуально "
  выходить" за пределы родительских контейнеров.
- Когда нужно избежать проблем с CSS-стилями:

`Избежание overflow:` Если родительский контейнер имеет стиль overflow: hidden, overflow: auto или overflow: scroll,
дочерние компоненты, рендерящиеся внутри этого контейнера, могут быть обрезаны или не отображаться полностью. Порталы
позволяют избежать этой проблемы, помещая модальные окна или всплывающие элементы в другой контейнер, который не
ограничен стилями родительского элемента.

`Позиционирование:` При использовании абсолютного или фиксированного позиционирования (например, position: absolute,
position: fixed) дочерние компоненты могут неправильно позиционироваться относительно родителя. Порталы могут помочь,
позволяя элементам позиционироваться относительно корневого DOM-узла, а не родительского компонента.

`Проблемы со слоями:` Если у вас есть несколько компонентов, которые накладываются друг на друга, порталы могут
помочь избежать проблем с z-индексом, позволяя вам управлять порядком отображения компонентов, независимо от их места в
иерархии компонентов.

`Упрощение управления стилями:` При использовании порталов вы можете применить стили к модальным окнам и другим
всплывающим элементам без влияния на другие компоненты в родительской иерархии, что упрощает управление стилями и их
переиспользование.

## 18. Разница между состоянием (state) и пропсами (props)?

`props` — это данные, которые компонент получает извне (от родителя). Они неизменяемы внутри компонента и используются для настройки или передачи информации.

`state` — это внутренние данные компонента, которыми он сам управляет. Изменение state вызывает перерисовку компонента.

## 19. Что такое синтетические события?

`Синтетические события` — это обертка над нативными событиями браузера. Они создаются React для обеспечения
кросс-браузерной совместимости и улучшения производительности. Вот несколько ключевых моментов о синтетических событиях:

1. `Кросс-браузерная совместимость`: Синтетические события предоставляют единый интерфейс для событий, который
   работает одинаково во всех поддерживаемых браузерах, избегая различий в реализации событий между браузерами.

2. `Упрощение работы с событиями`: Синтетические события обеспечивают такие же свойства и методы, как и нативные
   события, например, `event.target`, `event.currentTarget`, `event.preventDefault()`, и `event.stopPropagation()`.

3. `Пул событий`: React использует пул событий, чтобы уменьшить количество объектов событий, создаваемых при каждом
   событии. Это позволяет эффективно управлять памятью. После того как событие обработано, React возвращает его в пул,
   что означает, что доступ к свойствам события возможен только внутри обработчика.

4. `Проброс событий`: Синтетические события поддерживают концепцию проброса событий (event bubbling), то есть они
   проходят через цепочку элементов от целевого элемента до корня дерева.

```jsx
function handleClick(event) {
    // Событие здесь будет синтетическим
    console.log(event.type); // 'click'
    console.log(event.target); // Целевой элемент
}

function App() {
    return (
        <button onClick={handleClick}>Click me</button>
    );
}
```

## 20. Что такое условный рендеринг (Conditional Rendering)?

`Условный рендеринг` позволяет отображать компоненты или элементы в зависимости от условий. Это можно сделать с помощью
условных операторов (`if`, тернарный оператор) внутри метода рендера или функции.

## 21. Разница между React и ReactDOM?

**`React`**: Библиотека для создания компонентов и управления состоянием.

**`ReactDOM`**: Библиотека, которая отвечает за рендеринг React-компонентов в реальный DOM.

## 22. Что такое строгий режим? Его преимущества?

`Строгий режим (<React.StrictMode>)` помогает выявлять потенциальные проблемы в приложении, такие как устаревшие API и
небезопасные методы. Он активирует дополнительные проверки и предупреждения в режиме разработки.

## 23. Что такое «бурение пропсов» (Prop Drilling)? Как его избежать?

`Бурение пропсов` — это процесс передачи данных от родительского компонента через несколько уровней дочерних
компонентов.
Это можно избежать, используя контекст или менеджер состояния.

## 24. Что такое «опрос» (Polling)? Как его реализовать?

`Опрос (Polling)` — это метод регулярного получения данных от сервера. Реализуется с помощью `setInterval` для
периодического вызова
API в компоненте и обновления состояния.

## 25. Что такое сhildren?

`children` — это специальный пропс, который используется для передачи вложенных элементов или компонентов в компонент.

## 26. Что такое инверсия управления?

`Инверсия управления (IoC)` — это принцип, при котором компонент не управляет поведением сам, а делегирует управление извне (например, через props, колбэки или render props).

## 27. Разница между классовым и функциональным компонентами?

`Классовые компоненты`:  Определяются как классы, поддерживают методы жизненного цикла и могут
использовать состояние.

`Функциональные компоненты`: Определяются как функции и могут использовать хуки для управления состоянием, жизненным циклом и другими возможностями React.

## 28. Что такое поднятие состояния вверх (Lifting State Up)?

`Поднятие состояния вверх (Lifting State Up)` — это паттерн, когда несколько компонентов должны использовать одно и то же состояние. Вместо хранения состояния в каждом компоненте отдельно, оно поднимается в ближайший общий родитель, который управляет состоянием и передаёт его дочерним компонентам через props.

## 29. Что такое обратный поток данных?

`Обратный поток данных` — это когда данные передаются от дочернего компонента к родительскому. Обычно данные идут сверху вниз через props, но иногда дочерний компонент должен сообщить родителю о событиях или изменениях.
Суть: родитель передаёт функцию, а дочерний компонент вызывает её, чтобы «поднять» данные вверх.

## 30. Разница между createElement() и cloneElement()?

- `createElement()`:
    - Используется для создания нового элемента React.
    - Формат вызова: `React.createElement(type, props, ...children)`.
    - `type` — это тип элемента (например, строка для HTML-элемента или класс/функция для пользовательского компонента).
    - `props` — объект с атрибутами и свойствами элемента.
    - `children` — дочерние элементы, которые будут вложены в создаваемый элемент.

   ```jsx
   const element = React.createElement('div', { className: 'my-class' }, 'Hello, world!');
   ```

   Этот код создаст элемент `<div className="my-class">Hello, world!</div>`.

- `cloneElement()`:
    - Используется для создания копии существующего элемента React с возможностью изменения его свойств.
    - Формат вызова: `React.cloneElement(element, [props], [...children])`.
    - `element` — это React-элемент, который вы хотите клонировать.
    - `props` — объект с новыми или измененными свойствами, которые вы хотите применить к клонированному элементу.
    - `children` — новые дочерние элементы, которые вы хотите добавить или заменить в клонированном элементе.

   ```jsx
   const element = <div className="my-class">Hello, world!</div>;
   const clonedElement = React.cloneElement(element, { className: 'new-class' });
   ```

В этом примере `clonedElement` будет `<div className="new-class">Hello, world!</div>`.

## 31. Что такое распределенный компонент?

`Распределенный компонент (Composed component)` — это компонент, который построен из нескольких других
компонентов. Такая структура позволяет разделять функциональность на более мелкие и переиспользуемые части.

```jsx
// Крупный компонент
const UserProfile = () => {
    return (
        <div>
            <UserAvatar/>
            <UserName/>
            <UserBio/>
        </div>
    );
};

// Меньшие компоненты
const UserAvatar = () => <img src="avatar.jpg" alt="User Avatar"/>;
const UserName = () => <h1>John Doe</h1>;
const UserBio = () => <p>This is a user bio.</p>;
```

Преимущества распределенных компонентов:

- **Уменьшение дублирования кода**: Компонент используется в нескольких местах с разной конфигурацией.
- **Оптимизация производительности**: Компоненты загружаются только тогда, когда они действительно необходимы.
- **Упрощение управления состоянием**: Можно использовать контекст или другие подходы для передачи состояния между
  распределенными компонентами.

## 32. Как отрендерить HTML код компоненте?

Можно использовать `dangerouslySetInnerHTML`, чтобы вставить HTML-код непосредственно в компонент. Это
позволяет вам рендерить HTML-код, который вы получили из внешнего источника или динамически сгенерировали. Однако, как
следует из названия, этот метод может представлять риски безопасности, такие как XSS-атаки, если HTML-код не был должным
образом очищен или проверен.

```jsx
import React from 'react';

const HtmlRenderer = ({html}) => {
    return (
        <div dangerouslySetInnerHTML={{__html: html}}/>
    );
};

export default HtmlRenderer;
```

## 33. Является ли React реактивным?

`Да`, React является реактивной библиотекой.
В контексте разработки "реактивность" означает, что пользовательский интерфейс (UI) автоматически обновляется при
изменении данных.
Это достигается благодаря использованию состояния и жизненного цикла компонентов.

Когда состояние компонента изменяется, React автоматически перерисовывает этот компонент и его дочерние компоненты,
что позволяет разработчикам сосредоточиться на логике приложения, а не на управлении обновлением интерфейса.
Эта реактивная природа делает разработку более удобной и упрощает создание сложных интерфейсов.

## 34. Что такое батчинг ререндеров?

`Батчинг` — это объединение нескольких вызовов обновления состояния в один ререндер для оптимизации.

- До React 18 батчинг был только внутри синхронных обработчиков событий.

- Начиная с React 18, батчинг работает и в асинхронных сценариях (таймауты, промисы, fetch, async/await).

`Как отменить батчинг?`

В современных версиях React (18+) отключить батчинг напрямую нельзя — он всегда включён.
Единственный «официальный» способ форсировать немедленный ререндер — использовать flushSync из react-dom:

```javascript
import { flushSync } from "react-dom";

function App() {
  const [count, setCount] = useState(0);
  const [text, setText] = useState("init");

  const handleClick = () => {
    flushSync(() => {
      setCount((c) => c + 1); // выполнится сразу
    });
    setText("Updated!"); // это уже пойдёт в отдельный батч
  };

  return (
    <>
      <div>{count}</div>
      <div>{text}</div>
      <button onClick={handleClick}>Click</button>
    </>
  );
}
```

## 35. Что такое React.lazy?

`React.lazy` — это функция, которая позволяет загружать компоненты лениво, то есть только тогда, когда они реально нужны. Это помогает уменьшить размер начальной сборки приложения и улучшить время загрузки.

```javascript
import React, { Suspense } from 'react';

const LazyComponent = React.lazy(() => import('./LazyComponent'));

function App() {
  return (
    <div>
      <h1>Главная страница</h1>
      <Suspense fallback={<div>Загрузка...</div>}>
        <LazyComponent />
      </Suspense>
    </div>
  );
}

export default App;
```

**Ограничения и нюансы:**

1. Работает только с default export компонентов.

2. Не подходит для серверного рендеринга без специальных библиотек (например, React.lazy на SSR не поддерживается).

3. Ошибки при загрузке модуля нужно обрабатывать через Error Boundaries, иначе приложение может сломаться.

4. Можно лениво загружать только React-компоненты, а не обычные функции или объекты.

## 36. В каких ситуациях строят SPA, а в каких SSR?

`SPA (Single Page Application)`

Когда выбирают:

- Интерактивные веб-приложения с частыми изменениями интерфейса без перезагрузки (панели, дашборды, редакторы, чаты).

- Когда важна плавная работа интерфейса и быстрый отклик пользователя.

- Основная нагрузка на клиент — рендеринг и взаимодействие с API.

Плюсы:

- Плавная работа, меньше перезагрузок страницы.

- Можно кэшировать ресурсы на клиенте.

Минусы:

- SEO хуже из коробки.

- Первичная загрузка может быть медленнее.

`SSR (Server-Side Rendering)`

Когда выбирают:

- Контентные сайты и страницы, важные для SEO (интернет-магазины, блоги, новостные порталы).

- Когда важна быстрая первичная загрузка страницы для пользователя.

- Сервер генерирует HTML, клиент получает готовый контент.

Плюсы:

- Хорошее SEO.

- Быстрая первичная загрузка.

Минусы:

- Более сложная архитектура.

- Каждый переход требует запроса к серверу (можно комбинировать с CSR/SPA для гибридных решений).

💡 Итог:

`SPA` — для интерактивного опыта пользователя и динамичных интерфейсов.

`SSR` — для SEO и быстрой первичной загрузки контента.

## 37. Какие существуют альтернативы помимо SPA и SSR?

1. CSR (Client-Side Rendering)

   - Классический подход, где браузер рендерит весь контент на стороне клиента после загрузки JS.

   - Применяется для интерактивных приложений, но SEO из коробки слабее, чем у SSR.

2. Static Site Generation (SSG)

   - Страницы заранее собираются на этапе сборки (build time) и отдаются как готовый HTML.

   - Подходит для блогов, документации, лендингов.

   - Быстрая загрузка, хорошее SEO.

3. Incremental Static Regeneration (ISR)

   - Комбинирует SSG и SSR: статические страницы обновляются периодически или по событию.

   - Используется в Next.js для больших сайтов с динамическим контентом.

4. Hybrid / Jamstack

   - Сочетание статической генерации и динамического JS.

   - Сервер отдаёт готовый HTML, а интерактивность реализуется через JS на клиенте.

   - Хорошо подходит для сайтов с высокой производительностью и SEO.